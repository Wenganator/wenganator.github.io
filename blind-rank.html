<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blind Rank</title>
    
    <!-- Favicon links (generated by favicon.io) -->
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon/favicon-16x16.png">
    <link rel="manifest" href="/assets/favicon/site.webmanifest">

    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .card {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        h1 {
            font-size: 28px;
            color: #333;
            margin-bottom: 20px;
        }
        
        h2 {
            font-size: 22px;
            color: #555;
            margin-bottom: 16px;
        }
        
        h3 {
            font-size: 18px;
            color: #666;
            margin-bottom: 12px;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 12px;
        }
        
        textarea {
            resize: vertical;
            min-height: 60px;
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-primary {
            background: #667eea;
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            background: #5568d3;
        }
        
        .btn-success {
            background: #48bb78;
            color: white;
        }
        
        .btn-success:hover:not(:disabled) {
            background: #38a169;
        }
        
        .btn-danger {
            background: #f56565;
            color: white;
        }
        
        .btn-danger:hover {
            background: #e53e3e;
        }

        .btn-warning {
            background: #ed8936;
            color: white;
        }

        .btn-warning:hover:not(:disabled) {
            background: #dd6b20;
        }
        
        .players-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
        }
        
        .player-card {
            background: #f7fafc;
            padding: 16px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #e2e8f0;
        }
        
        .player-card.me {
            background: #667eea;
            color: white;
            border-color: #5568d3;
        }
        
        .playing-card {
            font-size: 48px;
            margin: 8px 0;
        }

        .red-suit {
            color: #dc2626;
        }
        
        .alert {
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }
        
        .alert-error {
            background: #fed7d7;
            color: #742a2a;
            border: 1px solid #fc8181;
        }
        
        .alert-info {
            background: #bee3f8;
            color: #2c5282;
            border: 1px solid #4299e1;
        }
        
        .alert-success {
            background: #c6f6d5;
            color: #22543d;
            border: 1px solid #48bb78;
        }
        
        .phase-banner {
            background: #fef5e7;
            padding: 16px;
            border-radius: 8px;
            border-left: 4px solid #f39c12;
            margin-bottom: 20px;
        }
        
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 16px;
        }
        
        .result-card {
            background: #f7fafc;
            padding: 16px;
            border-radius: 8px;
            border: 2px solid #e2e8f0;
        }
        
        .correct {
            color: #48bb78;
        }
        
        .incorrect {
            color: #f56565;
        }
        
        .score-banner {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 24px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .hidden {
            display: none;
        }
        
        .btn-group {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }
        
        .announcement-list {
            background: #ebf8ff;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .announcement-item {
            margin-bottom: 8px;
            padding: 8px;
            background: white;
            border-radius: 4px;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 18px;
            color: white;
        }

        .game-code-box {
            background: #f7fafc;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #4299e1;
            text-align: center;
            margin: 20px 0;
        }

        .game-code {
            font-size: 32px;
            font-weight: bold;
            color: #667eea;
            letter-spacing: 4px;
            margin: 12px 0;
            font-family: monospace;
        }

        .copy-button {
            background: #4299e1;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 8px;
        }

        .copy-button:hover {
            background: #3182ce;
        }

        .settings-box {
            background: #f7fafc;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .settings-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .settings-row label {
            flex: 1;
            font-weight: 500;
        }

        .settings-row input {
            width: 80px;
            margin: 0;
        }

        .turn-order {
            background: #e6fffa;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            border-left: 4px solid #38b2ac;
        }

        .chat-box {
            background: #f7fafc;
            border-radius: 8px;
            padding: 16px;
            margin-top: 20px;
        }

        .chat-messages {
            max-height: 200px;
            overflow-y: auto;
            background: white;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .chat-message {
            margin-bottom: 8px;
            padding: 8px;
            background: #edf2f7;
            border-radius: 4px;
        }

        .chat-message strong {
            color: #667eea;
        }

        .chat-input-group {
            display: flex;
            gap: 8px;
        }

        .chat-input-group input {
            flex: 1;
            margin: 0;
        }

        .chat-input-group button {
            margin: 0;
        }

        .session-results {
            background: #faf5ff;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .game-history-item {
            background: white;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 12px;
            border-left: 4px solid #9f7aea;
        }

        .announcement-input-box {
            background: #fef5e7;
            padding: 16px;
            border-radius: 8px;
            border: 2px solid #f39c12;
            margin-bottom: 16px;
        }

        .instructions-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
        }

        .instructions-content {
            background: white;
            border-radius: 12px;
            padding: 32px;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }

        .instructions-close {
            position: absolute;
            top: 16px;
            right: 16px;
            background: #e53e3e;
            color: white;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            cursor: pointer;
            font-size: 20px;
            line-height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .settings-row-flex {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 8px;
            background: white;
            border-radius: 6px;
        }

        .settings-row-flex label {
            flex: 1;
            margin: 0;
        }

        .settings-row-flex input[type="checkbox"],
        .settings-row-flex input[type="number"] {
            width: auto;
            margin: 0;
        }

        .settings-indent {
            margin-left: 20px;
            padding-left: 12px;
            border-left: 3px solid #e2e8f0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="app">
            <div class="loading">Loading game...</div>
        </div>
    </div>

    <script>
        // REPLACE THESE WITH YOUR FIREBASE CONFIG
        const firebaseConfig = {
            apiKey: "AIzaSyCx-m0HeY6i7wyzq9TWKyykpzr_Bv684Po",
            authDomain: "blind-rank.firebaseapp.com",
            databaseURL: "https://blind-rank-default-rtdb.firebaseio.com",
            projectId: "blind-rank",
            storageBucket: "blind-rank.firebasestorage.app",
            messagingSenderId: "1087187727443",
            appId: "1:1087187727443:web:adfe42d823a556c66f02a6",
            measurementId: "G-DDML51FCX2"
        };

        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        const SUITS = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
        const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const RANKS_HIGH_TO_LOW = ['A', 'K', 'Q', 'J', '10', '9', '8', '7', '6', '5', '4', '3', '2'];
        const RANK_VALUES = { 'A': 14, 'K': 13, 'Q': 12, 'J': 11, '10': 10, '9': 9, '8': 8, '7': 7, '6': 6, '5': 5, '4': 4, '3': 3, '2': 2 };

        let gameState = null;
        let playerName = localStorage.getItem('playerName') || '';
        let gameId = null;
        let gameRef = null;
        let lastPlayerCount = 0;

        function getCardHTML(rank, suit) {
            const isRed = suit === '‚ô•' || suit === '‚ô¶';
            return `<span class="${isRed ? 'red-suit' : ''}">${rank}${suit}</span>`;
        }

        function getGameId() {
            const urlParams = new URLSearchParams(window.location.search);
            const urlGameId = urlParams.get('game');
            
            if (urlGameId) {
                localStorage.setItem('currentGameId', urlGameId);
                return urlGameId;
            }
            
            return localStorage.getItem('currentGameId');
        }

        function generateGameCode() {
            const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += characters.charAt(Math.floor(Math.random() * characters.length));
            }
            return code;
        }

        function updateURL(newGameId) {
            const url = new URL(window.location);
            url.searchParams.set('game', newGameId);
            window.history.pushState({}, '', url);
        }

        function createDeck() {
            const deck = [];
            for (let rank of RANKS) {
                for (let suit of SUITS) {
                    deck.push({ rank, suit });
                }
            }
            return deck.sort(() => Math.random() - 0.5);
        }

        function calculateRelativeRanks(players) {
            const sorted = [...players].sort((a, b) => 
                RANK_VALUES[b.card.rank] - RANK_VALUES[a.card.rank]
            );

            const ranks = new Map();
            let currentRank = 1;
            
            sorted.forEach((player, idx) => {
                if (idx > 0 && RANK_VALUES[player.card.rank] < RANK_VALUES[sorted[idx - 1].card.rank]) {
                    currentRank = ranks.size + 1;
                }
                ranks.set(player.name, currentRank);
            });

            return ranks;
        }

        function getNumRelativeRanks(players) {
            const values = players.map(p => RANK_VALUES[p.card.rank]);
            const uniqueValues = [...new Set(values)];
            return uniqueValues.length;
        }

        function render() {
            const app = document.getElementById('app');
            
            // Check for player left notification
            if (gameState && gameState.playerLeftNotification && gameState.awaitingHostDecision) {
                app.innerHTML = renderPlayerLeftNotification();
                attachEventListeners();
                return;
            }
            
            if (!gameId) {
                app.innerHTML = renderLobby();
            } else if (!gameState) {
                app.innerHTML = '<div class="loading">Loading game...</div>';
            } else if (gameState.phase === 'setup') {
                app.innerHTML = renderSetup();
            } else if (gameState.phase === 'waiting') {
                app.innerHTML = renderWaiting();
            } else if (gameState.phase === 'announcing') {
                app.innerHTML = renderAnnouncing();
            } else if (gameState.phase === 'round1') {
                app.innerHTML = renderRound1();
            } else if (gameState.phase === 'round2') {
                app.innerHTML = renderRound2();
            } else if (gameState.phase === 'finished') {
                app.innerHTML = renderResults();
            }
            
            attachEventListeners();
        }

        function renderPlayerLeftNotification() {
            const notification = gameState.playerLeftNotification;
            const isHost = gameState.players[0].name === playerName;
            
            return `
                <div class="card">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <div>
                            <h1>üé¥ Blind Rank</h1>
                            <p style="font-size: 20px; font-style: italic; color: #666;">Player Left</p>
                        </div>
                    </div>
                    
                    <div class="alert alert-error">
                        <h3 style="margin-bottom: 8px;">‚ö†Ô∏è ${notification.playerName} has left the game</h3>
                        ${notification.wasHost ? `<p><strong>${notification.newHost}</strong> is now the host.</p>` : ''}
                    </div>
                    
                    ${isHost ? `
                        <div class="alert alert-info" style="margin-top: 20px;">
                            <h3 style="margin-bottom: 12px;">What would you like to do?</h3>
                            <p style="margin-bottom: 16px;">You can continue the game without ${notification.playerName}, or end the game and return to setup.</p>
                            <div class="btn-group">
                                <button class="btn-success" onclick="continueWithoutPlayer()">Continue Game</button>
                                <button class="btn-danger" onclick="endGameDueToLeave()">End Game</button>
                            </div>
                        </div>
                    ` : `
                        <div class="alert alert-info" style="margin-top: 20px;">
                            Waiting for the host (<strong>${gameState.players[0].name}</strong>) to decide whether to continue or end the game...
                        </div>
                    `}
                    
                    <h3 style="margin-top: 24px;">Remaining Players (${gameState.players.length})</h3>
                    <div class="players-grid">
                        ${gameState.players.map((p, idx) => `
                            <div class="player-card ${p.name === playerName ? 'me' : ''}">
                                ${p.name} ${idx === 0 ? 'üëë' : ''}
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function renderLobby() {
            return `
                <div class="card">
                    <h1>üé¥ Blind Rank</h1>
                    <p style="font-size: 20px; font-style: italic; color: #666; margin-bottom: 20px;">A Cooperative Card Game</p>
                    <button class="btn-primary" onclick="showInstructions()" style="margin-bottom: 24px; padding: 8px 16px; font-size: 14px;">üìñ How to Play</button>
                    
                    <div style="margin-bottom: 24px;">
                        <h2>Create New Game</h2>
                        <input type="text" id="newGameName" placeholder="Enter your name" value="${playerName}">
                        <button class="btn-primary" onclick="startNewGame()">Create Game</button>
                    </div>
                    <div style="border-top: 2px solid #e2e8f0; padding-top: 24px;">
                        <h2>Join Existing Game</h2>
                        <input type="text" id="joinGameCode" placeholder="Enter 6-digit game code (e.g., ABC123)" maxlength="6" style="text-transform: uppercase;">
                        <input type="text" id="joinGameName" placeholder="Enter your name" value="${playerName}">
                        <button class="btn-success" onclick="joinGame()">Join Game</button>
                    </div>
                    <div id="error" class="hidden"></div>
                </div>
            `;
        }

        function showInstructions() {
            const modal = document.createElement('div');
            modal.className = 'instructions-modal';
            modal.onclick = (e) => {
                if (e.target === modal) hideInstructions();
            };
            
            modal.innerHTML = `
                <div class="instructions-content">
                    <button class="instructions-close" onclick="hideInstructions()">√ó</button>
                    <h1 style="margin-bottom: 16px;">üé¥ How to Play Blind Rank</h1>
                    
                    <h2 style="color: #667eea; margin-top: 24px;">Game Overview</h2>
                    <p>Blind Rank is a cooperative card game where players work together to guess their card ranks without seeing their own cards. The goal is to maximize your team's score by making accurate guesses.</p>
                    
                    <h2 style="color: #667eea; margin-top: 24px;">Quick Start</h2>
                    <ol style="line-height: 1.8;">
                        <li><strong>Setup:</strong> Host creates a game and sets scoring rules. Players join using the game code or link.</li>
                        <li><strong>Deal:</strong> Each player receives one card face-up that only other players can see.</li>
                        <li><strong>Announcement Phase:</strong> Players announce if they see duplicate cards (pairs, triples, etc.).</li>
                        <li><strong>Round 1:</strong> Each player guesses their card's relative rank (1 = highest).</li>
                        <li><strong>Round 2:</strong> Each player guesses their relative rank AND card identity, then reveals.</li>
                        <li><strong>Scoring:</strong> Earn points for correct guesses based on the scoring rules set by the host.</li>
                    </ol>
                    
                    <h2 style="color: #667eea; margin-top: 24px;">Detailed Rules</h2>
                    
                    <h3 style="margin-top: 16px;">Understanding Relative Ranks</h3>
                    <p><strong>Relative rank</strong> refers to how your card compares to all cards in play:</p>
                    <ul style="line-height: 1.8; margin-bottom: 12px;">
                        <li>Relative rank 1 = highest card(s) in play</li>
                        <li>Relative rank 2 = second highest card(s)</li>
                        <li>And so on...</li>
                    </ul>
                    
                    <p><strong>Important:</strong> Cards of the same rank (but different suits) share the same relative rank.</p>
                    
                    <p style="margin-top: 12px;"><strong>Example 1:</strong> Cards in play are <span class="red-suit">A‚ô†</span>, <span class="red-suit">K‚ô•</span>, <span class="red-suit">7‚ô¶</span>, 2‚ô£</p>
                    <ul style="line-height: 1.6;">
                        <li>A‚ô† has relative rank 1 (highest)</li>
                        <li><span class="red-suit">K‚ô•</span> has relative rank 2</li>
                        <li><span class="red-suit">7‚ô¶</span> has relative rank 3</li>
                        <li>2‚ô£ has relative rank 4 (lowest)</li>
                        <li>Total: 4 relative ranks</li>
                    </ul>
                    
                    <p style="margin-top: 12px;"><strong>Example 2:</strong> Cards in play are A‚ô†, <span class="red-suit">A‚ô•</span>, <span class="red-suit">7‚ô¶</span>, 7‚ô£, 2‚ô†</p>
                    <ul style="line-height: 1.6;">
                        <li>Both A‚ô† and <span class="red-suit">A‚ô•</span> have relative rank 1 (highest)</li>
                        <li>Both <span class="red-suit">7‚ô¶</span> and 7‚ô£ have relative rank 2</li>
                        <li>2‚ô† has relative rank 3 (lowest)</li>
                        <li>Total: 3 relative ranks (even though there are 5 cards)</li>
                    </ul>
                    
                    <p style="margin-top: 12px;"><strong>Critical Edge Case:</strong> Cards in play are A‚ô†, <span class="red-suit">A‚ô•</span>, <span class="red-suit">7‚ô¶</span>, 7‚ô£</p>
                    <ul style="line-height: 1.6;">
                        <li>One player with an A announces "I see a pair" (they see <span class="red-suit">7‚ô¶</span>, 7‚ô£)</li>
                        <li>Everyone else also only sees one pair, so no one makes additional announcements</li>
                        <li>Players will assume there are 3 relative ranks (4 cards with 1 pair)</li>
                        <li><strong>BUT</strong> the true answer is only 2 relative ranks (two pairs!)</li>
                        <li>No one knows the true count until all cards are revealed</li>
                        <li>This is why the game allows guesses from 1 to N (number of players)</li>
                    </ul>
                    
                    <p style="margin-top: 12px;"><strong>Extreme Edge Case:</strong> If everyone's card is part of a duplicate (e.g., A‚ô†, <span class="red-suit">A‚ô•</span>, <span class="red-suit">A‚ô¶</span>, A‚ô£), no one will know there's only 1 relative rank until all cards are revealed!</p>
                    
                    <h3 style="margin-top: 16px;">Announcement Phase</h3>
                    <p>Players look at everyone else's cards (but not their own):</p>
                    <ul style="line-height: 1.8;">
                        <li>If you see duplicates, click <strong>"Make Announcement"</strong> to claim the announcement slot</li>
                        <li>Describe what you see (e.g., "I see a pair" or "I see two pairs")</li>
                        <li>If another player sees MORE duplicates than announced, they can announce next</li>
                        <li>If you don't see any additional duplicates beyond what's been announced, click <strong>"I See No Further Duplicates"</strong></li>
                        <li>Once all players have either announced or clicked "No Further Duplicates," the host starts Round 1</li>
                        <li><strong>Important:</strong> Don't say which cards are duplicates or who has them - just that duplicates exist!</li>
                    </ul>
                    
                    <h3 style="margin-top: 16px;">Round 1: Relative Rank Guessing</h3>
                    <ul style="line-height: 1.8;">
                        <li>The last person to announce goes first; if no one announced, order is random</li>
                        <li>Players take turns guessing their card's relative rank (1 = highest)</li>
                        <li>You can see other players' cards and their guesses to help you decide</li>
                        <li>The host controls whether Round 1 guesses are scored (default: not scored)</li>
                    </ul>
                    
                    <h3 style="margin-top: 16px;">Round 2: Full Guessing</h3>
                    <ul style="line-height: 1.8;">
                        <li>Same turn order as Round 1</li>
                        <li>Guess your relative rank again (1 = highest)</li>
                        <li>Also guess your card identity (A, K, Q, J, 10, 9, 8, 7, 6, 5, 4, 3, 2)</li>
                        <li><strong>Note:</strong> You do NOT guess the suit - only the card rank</li>
                        <li>After guessing, your card is revealed to everyone (including you)</li>
                        <li>The host controls scoring for Round 2 guesses (default: scored)</li>
                    </ul>
                    
                    <h3 style="margin-top: 16px;">Scoring</h3>
                    <p>The host sets scoring rules at game start:</p>
                    <ul style="line-height: 1.8;">
                        <li><strong>Round 1 Scoring:</strong> Points for correct relative rank guess (default: 0 pts, not scored)</li>
                        <li><strong>Round 2 Scoring:</strong> Points for correct relative rank guess (default: 1 pt)</li>
                        <li><strong>Round 2 Scoring:</strong> Points for correct card identity guess (default: 2 pts)</li>
                    </ul>
                    <p style="margin-top: 12px;">Your team's goal is to maximize the total points across all players!</p>
                    
                    <h3 style="margin-top: 16px;">Session Mode</h3>
                    <ul style="line-height: 1.8;">
                        <li>After a game ends, the host can start a new game without recreating the room</li>
                        <li>Results from all games in the session are tracked and can be exported</li>
                        <li>Players can join or leave between games</li>
                        <li>If the host leaves, the next player becomes the new host</li>
                    </ul>
                    
                    <h3 style="margin-top: 16px;">Tips for Success</h3>
                    <ul style="line-height: 1.8;">
                        <li>Pay close attention to announcements - they give crucial information</li>
                        <li>Use other players' guesses to help inform your own</li>
                        <li>Remember that duplicate cards share the same relative rank</li>
                        <li>In Round 2, your Round 1 guess is shown to help you reassess</li>
                        <li>Thinking about what cards everyone else sees is key to team success!</li>
                    </ul>
                    
                    <div style="margin-top: 32px; text-align: center;">
                        <button class="btn-primary" onclick="hideInstructions()">Got it! Let's Play</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        function hideInstructions() {
            const modal = document.querySelector('.instructions-modal');
            if (modal) {
                modal.remove();
            }
        }

        function renderSetup() {
            const isHost = gameState.players[0].name === playerName;
            const gameUrl = window.location.origin + window.location.pathname + '?game=' + gameId;
            
            return `
                <div class="card">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <div>
                            <h1>üé¥ Blind Rank</h1>
                            <p style="font-size: 20px; font-style: italic; color: #666;">Game Setup</p>
                        </div>
                        <button class="btn-danger" onclick="leaveGame()">Leave Game</button>
                    </div>
                    
                    <div class="game-code-box">
                        <div style="font-size: 14px; color: #555; margin-bottom: 8px;">Share this game code with your friends:</div>
                        <div class="game-code">${gameId}</div>
                        <button class="copy-button" onclick="copyGameCode()">üìã Copy Game Code</button>
                        <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #e2e8f0;">
                            <div style="font-size: 12px; color: #666; margin-bottom: 8px;">Or share this link:</div>
                            <input type="text" id="gameUrl" value="${gameUrl}" readonly style="font-size: 12px; margin-bottom: 8px;">
                            <button class="copy-button" onclick="copyGameUrl()">üìã Copy Link</button>
                        </div>
                    </div>
                    
                    ${isHost ? `
                        <div class="settings-box">
                            <h3>‚öôÔ∏è Game Settings</h3>
                            <div class="settings-row-flex">
                                <label><strong>Score Round 1</strong> (Relative Rank Only)</label>
                                <input type="checkbox" id="scoreRound1" ${gameState.settings.scoreRound1 ? 'checked' : ''}>
                            </div>
                            <div id="round1Settings" style="${gameState.settings.scoreRound1 ? '' : 'display: none;'}">
                                <div class="settings-indent">
                                    <div class="settings-row-flex">
                                        <label>Points for correct relative rank (Round 1):</label>
                                        <input type="number" id="round1Points" value="${gameState.settings.round1Points || 1}" min="0" max="10" style="width: 60px;">
                                    </div>
                                </div>
                            </div>
                            
                            <div class="settings-row-flex">
                                <label><strong>Score Round 2</strong> (Relative Rank + Card Identity)</label>
                                <input type="checkbox" id="scoreRound2" ${gameState.settings.scoreRound2 ? 'checked' : ''}>
                            </div>
                            <div id="round2Settings" style="${gameState.settings.scoreRound2 ? '' : 'display: none;'}">
                                <div class="settings-indent">
                                    <div class="settings-row-flex">
                                        <label>Points for correct relative rank (Round 2):</label>
                                        <input type="number" id="round2RankPoints" value="${gameState.settings.round2RankPoints || 1}" min="0" max="10" style="width: 60px;">
                                    </div>
                                    <div class="settings-row-flex">
                                        <label>Points for correct card identity:</label>
                                        <input type="number" id="cardPoints" value="${gameState.settings.cardPoints || 2}" min="0" max="10" style="width: 60px;">
                                    </div>
                                </div>
                            </div>
                            <button class="btn-primary" onclick="updateSettings()" style="margin-top: 12px;">Save Settings</button>
                        </div>
                        <script>
                            document.getElementById('scoreRound1').addEventListener('change', function() {
                                document.getElementById('round1Settings').style.display = this.checked ? '' : 'none';
                            });
                            document.getElementById('scoreRound2').addEventListener('change', function() {
                                document.getElementById('round2Settings').style.display = this.checked ? '' : 'none';
                            });
                        <\/script>
                    ` : `
                        <div class="settings-box">
                            <h3>‚öôÔ∏è Current Settings</h3>
                            <p><strong>Round 1 Scoring:</strong> ${gameState.settings.scoreRound1 ? `Enabled (${gameState.settings.round1Points || 1} pt)` : 'Disabled'}</p>
                            <p><strong>Round 2 Scoring:</strong> ${gameState.settings.scoreRound2 ? `Enabled (${gameState.settings.round2RankPoints || 1} pt for rank, ${gameState.settings.cardPoints || 2} pts for card)` : 'Disabled'}</p>
                            <p style="margin-top: 8px; font-size: 14px; color: #666;">Only the host can change settings</p>
                        </div>
                    `}
                    
                    <h2>Players (${gameState.players.length})</h2>
                    <div class="players-grid">
                        ${gameState.players.map((p, idx) => `
                            <div class="player-card ${p.name === playerName ? 'me' : ''}">
                                ${p.name} ${idx === 0 ? 'üëë' : ''}
                            </div>
                        `).join('')}
                    </div>
                    
                    ${isHost ? `
                        <button class="btn-primary" onclick="startWaiting()" ${gameState.players.length < 2 ? 'disabled' : ''}>
                            Continue ${gameState.players.length < 2 ? '(Need 2+ players)' : ''}
                        </button>
                    ` : `
                        <div class="alert alert-info">Waiting for ${gameState.players[0].name} to continue...</div>
                    `}
                </div>
            `;
        }

        function renderWaiting() {
            const isHost = gameState.players[0].name === playerName;
            
            return `
                <div class="card">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <div>
                            <h1>üé¥ Blind Rank</h1>
                            <p style="font-size: 20px; font-style: italic; color: #666;">Ready to Start</p>
                        </div>
                        <button class="btn-danger" onclick="leaveGame()">Leave Game</button>
                    </div>
                    
                    <div class="alert alert-success">
                        All players are ready! When the host starts the game, cards will be dealt.
                    </div>
                    
                    <h2>Players (${gameState.players.length})</h2>
                    <div class="players-grid">
                        ${gameState.players.map((p, idx) => `
                            <div class="player-card ${p.name === playerName ? 'me' : ''}">
                                ${p.name} ${idx === 0 ? 'üëë' : ''}
                            </div>
                        `).join('')}
                    </div>
                    
                    ${isHost ? `
                        <button class="btn-success" onclick="dealCards()">Deal Cards & Start Game</button>
                    ` : `
                        <div class="alert alert-info">Waiting for ${gameState.players[0].name} to deal cards...</div>
                    `}
                </div>
            `;
        }

        function renderAnnouncing() {
            const myPlayer = gameState.players.find(p => p.name === playerName);
            const announcer = gameState.currentAnnouncer;
            const noAnnouncePlayers = gameState.noAnnouncementPlayers || [];
            const isMyTurnToAnnounce = announcer === playerName;
            const haveIClickedNoAnnounce = noAnnouncePlayers.includes(playerName);
            const canClickAnnounce = !announcer && !haveIClickedNoAnnounce;
            const allClickedNoAnnounce = noAnnouncePlayers.length === gameState.players.length;
            const isHost = gameState.players[0].name === playerName;
            
            return `
                <div class="card">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <div>
                            <h1>üé¥ Announcement Phase</h1>
                        </div>
                        <button class="btn-danger" onclick="leaveGame()">Leave Game</button>
                    </div>
                    
                    <div class="phase-banner">
                        <strong>Look at other players' cards.</strong> If you see duplicates (pairs, triples, etc.), click "Make Announcement" and describe how many duplicates you see. After someone has made an announcement, only players who see MORE duplicates can announce next. If you see no further duplicates beyond what's been announced, click "I See No Further Duplicates."
                    </div>
                    
                    ${announcer ? `
                        <div class="announcement-input-box">
                            ${isMyTurnToAnnounce ? `
                                <h3>‚úèÔ∏è Your turn to announce</h3>
                                <p style="margin-bottom: 12px;">Describe the duplicates you see (e.g., "I see a pair" or "I see two pairs")</p>
                                <textarea id="announcementText" placeholder="Enter your announcement..."></textarea>
                                <div class="btn-group">
                                    <button class="btn-success" onclick="submitAnnouncement()">Submit Announcement</button>
                                    <button class="btn-warning" onclick="cancelAnnouncement()">Cancel</button>
                                </div>
                            ` : `
                                <p><strong>${announcer}</strong> is making an announcement...</p>
                            `}
                        </div>
                    ` : ''}
                    
                    <h2>Other Players' Cards</h2>
                    <div class="players-grid">
                        ${gameState.players.filter(p => p.name !== playerName).map(p => `
                            <div class="player-card">
                                <div><strong>${p.name}</strong></div>
                                <div class="playing-card">${getCardHTML(p.card.rank, p.card.suit)}</div>
                            </div>
                        `).join('')}
                    </div>
                    
                    ${gameState.announcements && gameState.announcements.length > 0 ? `
                        <div class="announcement-list">
                            <strong>üì¢ Announcements:</strong>
                            ${gameState.announcements.map((a, idx) => `
                                <div class="announcement-item">
                                    <strong>${idx + 1}. ${a.player}:</strong> ${a.text}
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    <div style="margin-bottom: 12px;">
                        <strong>Players who see no further duplicates:</strong> ${noAnnouncePlayers.length}/${gameState.players.length}
                    </div>
                    
                    <div class="btn-group">
                        <button class="btn-primary" onclick="claimAnnouncement()" ${!canClickAnnounce ? 'disabled' : ''}>
                            ${haveIClickedNoAnnounce ? '‚úì You clicked No Further Duplicates' : 'Make Announcement'}
                        </button>
                        <button class="btn-warning" onclick="noAnnouncement()" ${announcer || haveIClickedNoAnnounce ? 'disabled' : ''}>
                            ${haveIClickedNoAnnounce ? '‚úì No Further Duplicates (Clicked)' : 'I See No Further Duplicates'}
                        </button>
                        ${allClickedNoAnnounce && isHost ? `
                            <button class="btn-success" onclick="startRound1()">Start Round 1</button>
                        ` : allClickedNoAnnounce && !isHost ? `
                            <div class="alert alert-info" style="margin: 0;">Waiting for host to start Round 1...</div>
                        ` : ''}
                    </div>
                </div>
            `;
        }

        function renderRound1() {
            const myPlayer = gameState.players.find(p => p.name === playerName);
            const turnOrder = gameState.turnOrder || [];
            const currentPlayerName = turnOrder[gameState.currentTurnIndex];
            const isMyTurn = currentPlayerName === playerName;
            const numPlayers = gameState.players.length;
            const myGuess = myPlayer && myPlayer.round1Guess !== null && myPlayer.round1Guess !== undefined ? myPlayer.round1Guess : null;
            
            return `
                <div class="card">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h1>üé¥ Round 1: Relative Rank Guessing</h1>
                        <button class="btn-danger" onclick="leaveGame()">Leave Game</button>
                    </div>
                    
                    <div class="turn-order">
                        <strong>Turn Order:</strong> ${turnOrder.map((name, idx) => {
                            const player = gameState.players.find(p => p.name === name);
                            const done = player && player.round1Guess !== null && player.round1Guess !== undefined;
                            const color = done ? '#48bb78' : (idx === gameState.currentTurnIndex ? '#667eea' : '#666');
                            const weight = idx === gameState.currentTurnIndex ? 'bold' : 'normal';
                            return '<span style="color: ' + color + '; font-weight: ' + weight + ';">' + name + (done ? ' ‚úì' : '') + '</span>';
                        }).join(' ‚Üí ')}
                    </div>
                    
                    <div class="phase-banner">
                        <strong>Current Turn:</strong> ${currentPlayerName}
                        ${isMyTurn ? ' (Your turn!)' : ''}
                        <br>
                        Guess a relative rank from 1 (highest) to ${numPlayers} (lowest possible). Remember that there may be fewer relative ranks than the number of cards in play if there are any duplicates.
                    </div>
                    
                    <h2>Other Players' Cards</h2>
                    <div class="players-grid">
                        ${gameState.players.filter(p => p.name !== playerName).map(p => {
                            return '<div class="player-card"><div><strong>' + p.name + '</strong></div><div class="playing-card">' + getCardHTML(p.card.rank, p.card.suit) + '</div>' + (p.round1Guess !== null && p.round1Guess !== undefined ? '<div class="correct">Relative Rank: ' + p.round1Guess + '</div>' : '') + '</div>';
                        }).join('')}
                    </div>
                    
                    ${isMyTurn && myGuess === null ? `
                        <div class="alert alert-info">
                            What is your card's relative rank?
                        </div>
                        <input type="number" id="round1Guess" min="1" max="${numPlayers}" placeholder="Relative rank">
                        <button class="btn-primary" onclick="submitRound1Guess()">Submit Relative Rank</button>
                    ` : myGuess !== null ? `
                        <div class="alert alert-success">
                            You guessed relative rank: <strong>${myGuess}</strong><br>
                            Waiting for other players...
                        </div>
                    ` : `
                        <div class="alert alert-info">Waiting for ${currentPlayerName} to guess...</div>
                    `}
                </div>
            `;
        }

        function renderRound2() {
            const myPlayer = gameState.players.find(p => p.name === playerName);
            const turnOrder = gameState.turnOrder || [];
            const currentPlayerName = turnOrder[gameState.currentTurnIndex];
            const isMyTurn = currentPlayerName === playerName;
            const numPlayers = gameState.players.length;
            const numRanks = getNumRelativeRanks(gameState.players);
            
            return `
                <div class="card">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h1>üé¥ Round 2: Card Identity Guessing</h1>
                        <button class="btn-danger" onclick="leaveGame()">Leave Game</button>
                    </div>
                    
                    <div class="turn-order">
                        <strong>Turn Order:</strong> ${turnOrder.map((name, idx) => {
                            const player = gameState.players.find(p => p.name === name);
                            const done = player && player.revealed;
                            const color = done ? '#48bb78' : (idx === gameState.currentTurnIndex ? '#667eea' : '#666');
                            const weight = idx === gameState.currentTurnIndex ? 'bold' : 'normal';
                            return '<span style="color: ' + color + '; font-weight: ' + weight + ';">' + name + (done ? ' ‚úì' : '') + '</span>';
                        }).join(' ‚Üí ')}
                    </div>
                    
                    <div class="phase-banner">
                        <strong>Current Turn:</strong> ${currentPlayerName}
                        ${isMyTurn ? ' (Your turn!)' : ''}
                        <br>
                        Guess your relative rank AND card identity
                    </div>
                    
                    <h2>Other Players' Cards</h2>
                    <div class="players-grid">
                        ${gameState.players.filter(p => p.name !== playerName).map(p => `
                            <div class="player-card">
                                <div><strong>${p.name}</strong></div>
                                <div class="playing-card">${getCardHTML(p.card.rank, p.card.suit)}</div>
                                <div style="font-size: 12px; margin-top: 4px;">Round 1: ${p.round1Guess}</div>
                                ${p.revealed && p.round2Guess ? `
                                    <div class="correct" style="font-size: 12px;">
                                        Guessed: Rank ${p.round2Guess.relativeRank}, ${p.round2Guess.cardRank}
                                    </div>
                                ` : ''}
                            </div>
                        `).join('')}
                    </div>
                    
                    ${isMyTurn && !myPlayer.revealed ? `
                        <div class="alert alert-info">
                            Guess your relative rank and card identity
                        </div>
                        <input type="number" id="round2RelativeRank" min="1" max="${numPlayers}" placeholder="Relative rank">
                        <select id="round2CardRank">
                            <option value="">Select card identity</option>
                            ${RANKS_HIGH_TO_LOW.map(r => `<option value="${r}">${r}</option>`).join('')}
                        </select>
                        <button class="btn-primary" onclick="submitRound2Guess()">Submit Guess & Reveal</button>
                    ` : myPlayer.revealed ? `
                        <div class="alert alert-success">
                            <strong>Your card:</strong> ${getCardHTML(myPlayer.card.rank, myPlayer.card.suit)}<br>
                            <strong>You guessed:</strong> Relative Rank ${myPlayer.round2Guess.relativeRank}, Card ${myPlayer.round2Guess.cardRank}<br>
                            Waiting for other players...
                        </div>
                    ` : `
                        <div class="alert alert-info">Waiting for ${currentPlayerName} to reveal...</div>
                    `}
                </div>
            `;
        }

        function renderResults() {
            const isHost = gameState.players[0].name === playerName;
            const results = calculateGameResults();
            const sessionHistory = gameState.sessionHistory || [];
            
            return `
                <div class="card">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h1>üèÜ Game Results</h1>
                        <button class="btn-danger" onclick="leaveGame()">Leave Session</button>
                    </div>
                    
                    <div class="score-banner">
                        <h2 style="color: white; margin-bottom: 12px;">Game ${sessionHistory.length} Results</h2>
                        <div style="font-size: 20px;">
                            Total Points Earned: <strong>${results.totalPoints}</strong>
                        </div>
                        <div style="font-size: 16px; margin-top: 12px; line-height: 1.6;">
                            ${gameState.settings.scoreRound1 ? `Correct Relative Ranks (Round 1): ${results.round1CorrectRanks}/${results.total} (${results.round1CorrectRanks * (gameState.settings.round1Points || 1)} pts)<br>` : ''}
                            ${gameState.settings.scoreRound2 ? `Correct Relative Ranks (Round 2): ${results.round2CorrectRanks}/${results.total} (${results.round2CorrectRanks * (gameState.settings.round2RankPoints || 1)} pts)<br>` : ''}
                            ${gameState.settings.scoreRound2 ? `Correct Card Identities: ${results.correctCards}/${results.total} (${results.correctCards * (gameState.settings.cardPoints || 2)} pts)` : ''}
                        </div>
                    </div>
                    
                    <h2>Individual Results</h2>
                    <div class="results-grid">
                        ${gameState.players.map(p => {
                            const relativeRanks = calculateRelativeRanks(gameState.players);
                            const actualRank = relativeRanks.get(p.name);
                            
                            const round1Correct = p.round1Guess === actualRank;
                            const round2RankCorrect = p.round2Guess.relativeRank === actualRank;
                            const round2CardCorrect = p.round2Guess.cardRank === p.card.rank;
                            
                            let points = 0;
                            if (gameState.settings.scoreRound1 && round1Correct) {
                                points += gameState.settings.round1Points || 1;
                            }
                            if (gameState.settings.scoreRound2) {
                                if (round2RankCorrect) points += gameState.settings.round2RankPoints || 1;
                                if (round2CardCorrect) points += gameState.settings.cardPoints || 2;
                            }
                            
                            return `
                                <div class="result-card">
                                    <div style="font-size: 18px; font-weight: bold; margin-bottom: 8px;">${p.name}</div>
                                    <div class="playing-card">${getCardHTML(p.card.rank, p.card.suit)}</div>
                                    <div style="margin-top: 8px; font-weight: bold;">Points: ${points}</div>
                                    <div class="${round1Correct ? 'correct' : 'incorrect'}" style="margin-top: 8px;">
                                        Round 1 Rank: ${p.round1Guess} (Actual: ${actualRank}) ${round1Correct ? '‚úì' : '‚úó'}
                                    </div>
                                    <div class="${round2RankCorrect ? 'correct' : 'incorrect'}">
                                        Round 2 Rank: ${p.round2Guess.relativeRank} (Actual: ${actualRank}) ${round2RankCorrect ? '‚úì' : '‚úó'}
                                    </div>
                                    <div class="${round2CardCorrect ? 'correct' : 'incorrect'}">
                                        Card Identity: ${p.round2Guess.cardRank} (Actual: ${p.card.rank}) ${round2CardCorrect ? '‚úì' : '‚úó'}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    
                    ${sessionHistory.length > 0 ? `
                        <div class="session-results">
                            <h2>üìä Session History (${sessionHistory.length} game${sessionHistory.length > 1 ? 's' : ''})</h2>
                            ${sessionHistory.map((game, idx) => `
                                <div class="game-history-item">
                                    <strong>Game ${idx + 1}</strong> - ${game.totalPoints} points
                                    <div style="font-size: 14px; margin-top: 4px;">
                                        Round 1 Ranks: ${game.round1CorrectRanks || 0}/${game.total} | 
                                        Round 2 Ranks: ${game.round2CorrectRanks || 0}/${game.total} | 
                                        Cards: ${game.correctCards}/${game.total}
                                    </div>
                                    ${game.turnOrder ? `
                                        <div style="font-size: 12px; margin-top: 6px; color: #666;">
                                            <strong>Turn order:</strong> ${game.turnOrder.join(' ‚Üí ')}
                                        </div>
                                    ` : ''}
                                    ${game.playerScores ? `
                                        <div style="font-size: 12px; margin-top: 4px;">
                                            ${game.playerScores.map(ps => `<span style="margin-right: 12px;">${ps.name}: ${ps.points} pts</span>`).join('')}
                                        </div>
                                    ` : ''}
                                </div>
                            `).join('')}
                            <button class="btn-primary" onclick="exportResults()" style="margin-top: 12px;">üì• Export All Results</button>
                        </div>
                    ` : ''}
                    
                    <div class="chat-box">
                        <h3>üí¨ Chat</h3>
                        <div class="chat-messages" id="chatMessages">
                            ${(gameState.chatMessages || []).map(msg => `
                                <div class="chat-message">
                                    <strong>${msg.player}:</strong> ${msg.text}
                                </div>
                            `).join('')}
                        </div>
                        <div class="chat-input-group">
                            <input type="text" id="chatInput" placeholder="Type a message..." onkeypress="if(event.key==='Enter') sendChatMessage()">
                            <button class="btn-primary" onclick="sendChatMessage()">Send</button>
                        </div>
                    </div>
                    
                    <div style="margin-top: 20px;">
                        ${isHost ? `
                            <div class="btn-group">
                                <button class="btn-success" onclick="startNewRound()" ${gameState.players.length < 2 ? 'disabled' : ''}>
                                    Start New Game ${gameState.players.length < 2 ? '(Need 2+ players)' : ''}
                                </button>
                                <button class="btn-warning" onclick="endSession()">End Session & Clear History</button>
                            </div>
                        ` : `
                            <div class="alert alert-info">
                                Waiting for ${gameState.players[0].name} to start a new game or end the session...
                            </div>
                        `}
                    </div>
                </div>
            `;
        }

        function calculateGameResults() {
            const relativeRanks = calculateRelativeRanks(gameState.players);
            let round1CorrectRanks = 0;
            let round2CorrectRanks = 0;
            let correctCards = 0;

            const playerScores = gameState.players.map(player => {
                const actualRank = relativeRanks.get(player.name);
                
                const round1Correct = player.round1Guess === actualRank;
                const round2RankCorrect = player.round2Guess.relativeRank === actualRank;
                const round2CardCorrect = player.round2Guess.cardRank === player.card.rank;
                
                if (round1Correct) round1CorrectRanks++;
                if (round2RankCorrect) round2CorrectRanks++;
                if (round2CardCorrect) correctCards++;
                
                let points = 0;
                if (gameState.settings.scoreRound1 && round1Correct) {
                    points += gameState.settings.round1Points || 1;
                }
                if (gameState.settings.scoreRound2) {
                    if (round2RankCorrect) points += gameState.settings.round2RankPoints || 1;
                    if (round2CardCorrect) points += gameState.settings.cardPoints || 2;
                }
                
                return {
                    name: player.name,
                    points: points,
                    round1Correct: round1Correct,
                    round2RankCorrect: round2RankCorrect,
                    round2CardCorrect: round2CardCorrect
                };
            });

            let totalPoints = 0;
            if (gameState.settings.scoreRound1) {
                totalPoints += round1CorrectRanks * (gameState.settings.round1Points || 1);
            }
            if (gameState.settings.scoreRound2) {
                totalPoints += round2CorrectRanks * (gameState.settings.round2RankPoints || 1);
                totalPoints += correctCards * (gameState.settings.cardPoints || 2);
            }

            return { 
                round1CorrectRanks,
                round2CorrectRanks,
                correctCards, 
                total: gameState.players.length,
                totalPoints,
                playerScores,
                turnOrder: gameState.turnOrder
            };
        }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            if (errorDiv) {
                errorDiv.className = 'alert alert-error';
                errorDiv.textContent = message;
            } else {
                alert(message);
            }
        }

        async function startNewGame() {
            const name = document.getElementById('newGameName').value.trim();
            if (!name) {
                showError('Please enter your name');
                return;
            }

            localStorage.setItem('playerName', name);
            playerName = name;

            const newGameId = generateGameCode();
            const newGame = {
                players: [{ 
                    name: name
                }],
                phase: 'setup',
                settings: {
                    scoreRound1: false,
                    round1Points: 1,
                    scoreRound2: true,
                    round2RankPoints: 1,
                    cardPoints: 2
                },
                sessionHistory: [],
                createdAt: Date.now()
            };

            await database.ref('games/' + newGameId).set(newGame);
            
            gameId = newGameId;
            localStorage.setItem('currentGameId', gameId);
            updateURL(gameId);
            setupGameListener();
        }

        async function joinGame() {
            const code = document.getElementById('joinGameCode') ? document.getElementById('joinGameCode').value.trim().toUpperCase() : '';
            const name = document.getElementById('joinGameName') ? document.getElementById('joinGameName').value.trim() : '';
            
            if (!code && !gameId) {
                showError('Please enter a game code');
                return;
            }
            
            if (!name) {
                showError('Please enter your name');
                return;
            }

            const targetGameId = code || gameId;
            const gameSnapshot = await database.ref('games/' + targetGameId).once('value');
            const game = gameSnapshot.val();
            
            if (!game) {
                showError('Game not found. Check the code and try again.');
                return;
            }

            if (game.phase !== 'setup' && game.phase !== 'finished') {
                showError('Cannot join - game is in progress');
                return;
            }

            if (game.players.some(p => p.name === name)) {
                showError('Name already taken');
                return;
            }

            localStorage.setItem('playerName', name);
            playerName = name;

            const updatedPlayers = [...game.players, { name: name }];

            await database.ref('games/' + targetGameId).update({
                players: updatedPlayers
            });

            gameId = targetGameId;
            localStorage.setItem('currentGameId', gameId);
            updateURL(gameId);
            setupGameListener();
        }

        async function updateSettings() {
            const scoreRound1 = document.getElementById('scoreRound1').checked;
            const scoreRound2 = document.getElementById('scoreRound2').checked;
            const round1Points = parseInt(document.getElementById('round1Points')?.value || 1);
            const round2RankPoints = parseInt(document.getElementById('round2RankPoints')?.value || 1);
            const cardPoints = parseInt(document.getElementById('cardPoints')?.value || 2);

            if (round1Points < 0 || round2RankPoints < 0 || cardPoints < 0) {
                showError('Points must be 0 or greater');
                return;
            }

            await gameRef.update({
                'settings/scoreRound1': scoreRound1,
                'settings/round1Points': round1Points,
                'settings/scoreRound2': scoreRound2,
                'settings/round2RankPoints': round2RankPoints,
                'settings/cardPoints': cardPoints
            });
        }

        async function startWaiting() {
            if (gameState.players.length < 2) {
                showError('Need at least 2 players');
                return;
            }

            await gameRef.update({ phase: 'waiting' });
        }

        async function dealCards() {
            const deck = createDeck();
            const updatedPlayers = gameState.players.map((p, idx) => ({
                ...p,
                card: deck[idx],
                round1Guess: null,
                round2Guess: null,
                revealed: false
            }));

            await gameRef.update({
                players: updatedPlayers,
                phase: 'announcing',
                currentAnnouncer: null,
                announcements: [],
                noAnnouncementPlayers: []
            });
        }

        async function claimAnnouncement() {
            await gameRef.update({
                currentAnnouncer: playerName
            });
        }

        async function submitAnnouncement() {
            const text = document.getElementById('announcementText').value.trim();
            if (!text) {
                showError('Please enter an announcement');
                return;
            }

            const announcements = gameState.announcements || [];
            announcements.push({ player: playerName, text: text });

            await gameRef.update({
                announcements: announcements,
                currentAnnouncer: null
            });
        }

        async function cancelAnnouncement() {
            await gameRef.update({
                currentAnnouncer: null
            });
        }

        async function noAnnouncement() {
            const noAnnouncePlayers = gameState.noAnnouncementPlayers || [];
            noAnnouncePlayers.push(playerName);

            await gameRef.update({
                noAnnouncementPlayers: noAnnouncePlayers
            });
        }

        async function startRound1() {
            const announcements = gameState.announcements || [];
            let turnOrder;
            
            if (announcements.length > 0) {
                const lastAnnouncer = announcements[announcements.length - 1].player;
                const lastAnnouncerIndex = gameState.players.findIndex(p => p.name === lastAnnouncer);
                
                turnOrder = [];
                for (let i = 0; i < gameState.players.length; i++) {
                    const idx = (lastAnnouncerIndex + i) % gameState.players.length;
                    turnOrder.push(gameState.players[idx].name);
                }
            } else {
                const startIndex = Math.floor(Math.random() * gameState.players.length);
                turnOrder = [];
                for (let i = 0; i < gameState.players.length; i++) {
                    const idx = (startIndex + i) % gameState.players.length;
                    turnOrder.push(gameState.players[idx].name);
                }
            }

            await gameRef.update({
                phase: 'round1',
                turnOrder: turnOrder,
                currentTurnIndex: 0
            });
        }

        async function submitRound1Guess() {
            const guessInput = document.getElementById('round1Guess');
            if (!guessInput) {
                showError('Could not find input field');
                return;
            }
            
            const guess = parseInt(guessInput.value);
            const maxPossibleRank = gameState.players.length;
            
            if (isNaN(guess) || guess < 1 || guess > maxPossibleRank) {
                showError(`Relative rank must be between 1 and ${maxPossibleRank}`);
                return;
            }

            const playerIndex = gameState.players.findIndex(p => p.name === playerName);
            if (playerIndex === -1) {
                showError('Player not found');
                return;
            }

            const updatedPlayers = gameState.players.map((p, idx) => 
                idx === playerIndex ? { ...p, round1Guess: guess } : p
            );

            const allGuessed = updatedPlayers.every(p => p.round1Guess !== null && p.round1Guess !== undefined);
            const nextTurnIndex = gameState.currentTurnIndex + 1;

            await gameRef.update({
                players: updatedPlayers,
                currentTurnIndex: allGuessed ? 0 : nextTurnIndex,
                phase: allGuessed ? 'round2' : 'round1'
            });
        }

        async function submitRound2Guess() {
            const relativeRank = parseInt(document.getElementById('round2RelativeRank').value);
            const cardRank = document.getElementById('round2CardRank').value;
            const numPlayers = gameState.players.length;

            if (!relativeRank || relativeRank < 1 || relativeRank > numPlayers) {
                showError(`Relative rank must be between 1 and ${numPlayers}`);
                return;
            }

            if (!cardRank) {
                showError('Please select a card identity');
                return;
            }

            const playerIndex = gameState.players.findIndex(p => p.name === playerName);
            const updatedPlayers = [...gameState.players];
            updatedPlayers[playerIndex].round2Guess = { relativeRank, cardRank };
            updatedPlayers[playerIndex].revealed = true;

            const allRevealed = updatedPlayers.every(p => p.revealed);
            const nextTurnIndex = gameState.currentTurnIndex + 1;

            if (allRevealed) {
                const results = calculateGameResults();
                const sessionHistory = gameState.sessionHistory || [];
                sessionHistory.push(results);

                await gameRef.update({
                    players: updatedPlayers,
                    phase: 'finished',
                    sessionHistory: sessionHistory,
                    chatMessages: []
                });
            } else {
                await gameRef.update({
                    players: updatedPlayers,
                    currentTurnIndex: nextTurnIndex
                });
            }
        }

        async function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const text = input.value.trim();
            
            if (!text) return;

            const chatMessages = gameState.chatMessages || [];
            chatMessages.push({ player: playerName, text: text, timestamp: Date.now() });

            await gameRef.update({
                chatMessages: chatMessages
            });

            input.value = '';
            
            setTimeout(() => {
                const chatBox = document.getElementById('chatMessages');
                if (chatBox) chatBox.scrollTop = chatBox.scrollHeight;
            }, 100);
        }

        async function startNewRound() {
            if (gameState.players.length < 2) {
                showError('Need at least 2 players');
                return;
            }

            await gameRef.update({ phase: 'waiting' });
        }

        async function endSession() {
            if (confirm('Are you sure you want to end this session? All history will be cleared.')) {
                await gameRef.update({
                    sessionHistory: [],
                    phase: 'setup'
                });
            }
        }

        function exportResults() {
            const results = {
                gameCode: gameId,
                settings: gameState.settings,
                players: gameState.players.map(p => p.name),
                sessionHistory: gameState.sessionHistory,
                detailedResults: gameState.sessionHistory.map((game, gameNum) => ({
                    gameNumber: gameNum + 1,
                    totalPoints: game.totalPoints,
                    round1CorrectRanks: game.round1CorrectRanks || 0,
                    round2CorrectRanks: game.round2CorrectRanks || 0,
                    correctCards: game.correctCards,
                    turnOrder: game.turnOrder || [],
                    playerScores: game.playerScores || []
                }))
            };

            const dataStr = JSON.stringify(results, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `blind-rank-results-${gameId}-${Date.now()}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function leaveGame() {
            if (confirm('Are you sure you want to leave this game?')) {
                const playerIndex = gameState.players.findIndex(p => p.name === playerName);
                const wasHost = playerIndex === 0;
                const isInProgress = gameState.phase !== 'setup' && gameState.phase !== 'finished';
                
                if (wasHost && gameState.players.length > 1) {
                    // Host leaving - transfer to next player
                    const updatedPlayers = gameState.players.slice(1);
                    const notification = {
                        type: 'player-left',
                        playerName: playerName,
                        wasHost: true,
                        newHost: updatedPlayers[0].name,
                        timestamp: Date.now()
                    };
                    
                    if (isInProgress) {
                        gameRef.update({ 
                            players: updatedPlayers,
                            playerLeftNotification: notification,
                            awaitingHostDecision: true
                        });
                    } else {
                        gameRef.update({ players: updatedPlayers });
                    }
                } else if (gameState.players.length === 1) {
                    // Last player leaving - delete game
                    gameRef.remove();
                } else {
                    // Regular player leaving
                    const updatedPlayers = gameState.players.filter(p => p.name !== playerName);
                    const notification = {
                        type: 'player-left',
                        playerName: playerName,
                        wasHost: false,
                        timestamp: Date.now()
                    };
                    
                    if (isInProgress) {
                        gameRef.update({ 
                            players: updatedPlayers,
                            playerLeftNotification: notification,
                            awaitingHostDecision: true
                        });
                    } else {
                        gameRef.update({ players: updatedPlayers });
                    }
                }
                
                if (gameRef) gameRef.off();
                gameId = null;
                gameState = null;
                localStorage.removeItem('currentGameId');
                const url = new URL(window.location);
                url.searchParams.delete('game');
                window.history.pushState({}, '', url);
                render();
            }
        }

        async function continueWithoutPlayer() {
            const updatedPlayers = gameState.players.map(p => ({ ...p }));
            
            // Recalculate turn order if needed
            if (gameState.turnOrder) {
                const leftPlayerName = gameState.playerLeftNotification.playerName;
                const updatedTurnOrder = gameState.turnOrder.filter(name => name !== leftPlayerName);
                
                // Adjust current turn index
                let newTurnIndex = gameState.currentTurnIndex;
                if (gameState.currentTurnIndex >= updatedTurnOrder.length) {
                    newTurnIndex = 0;
                }
                
                await gameRef.update({
                    turnOrder: updatedTurnOrder,
                    currentTurnIndex: newTurnIndex,
                    playerLeftNotification: null,
                    awaitingHostDecision: false
                });
            } else {
                await gameRef.update({
                    playerLeftNotification: null,
                    awaitingHostDecision: false
                });
            }
        }

        async function endGameDueToLeave() {
            await gameRef.update({
                phase: 'setup',
                playerLeftNotification: null,
                awaitingHostDecision: false,
                sessionHistory: gameState.sessionHistory || []
            });
        }

        function copyGameCode() {
            navigator.clipboard.writeText(gameId).then(() => {
                alert('Game code copied to clipboard!');
            });
        }

        function copyGameUrl() {
            const urlInput = document.getElementById('gameUrl');
            urlInput.select();
            navigator.clipboard.writeText(urlInput.value).then(() => {
                alert('Game link copied to clipboard!');
            });
        }

        function attachEventListeners() {
            // Event listeners are attached via onclick in HTML
        }

        function setupGameListener() {
            if (gameRef) {
                gameRef.off();
            }
            
            gameRef = database.ref('games/' + gameId);
            
            gameRef.on('value', (snapshot) => {
                gameState = snapshot.val();
                
                if (!gameState) {
                    alert('This game has ended or been deleted.');
                    leaveGame();
                    return;
                }
                
                render();
            });
        }

        window.addEventListener('DOMContentLoaded', () => {
            gameId = getGameId();
            
            if (gameId) {
                database.ref('games/' + gameId).once('value').then((snapshot) => {
                    if (snapshot.val()) {
                        const game = snapshot.val();
                        
                        // Check if player is already in the game
                        const existingPlayer = game.players.find(p => p.name === playerName);
                        if (existingPlayer) {
                            // Player is rejoining - just set up listener
                            setupGameListener();
                        } else if (playerName && (game.phase === 'setup' || game.phase === 'finished')) {
                            // Player has a name but isn't in game, and game allows joining
                            setupGameListener();
                        } else {
                            // New player needs to join
                            setupGameListener();
                        }
                    } else {
                        alert('Game not found. Please create a new game or join with a valid code.');
                        localStorage.removeItem('currentGameId');
                        gameId = null;
                        render();
                    }
                });
            } else {
                render();
            }
        });
    </script>
</body>
</html>