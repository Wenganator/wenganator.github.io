<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal File Reader Pro</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        :root {
            --primary-color: #667eea;
            --secondary-color: #764ba2;
            --bg-color: #f8f9fa;
            --text-color: #333;
            --sidebar-bg: white;
        }
        
        [data-theme="dark"] {
            --primary-color: #667eea;
            --secondary-color: #764ba2;
            --bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --sidebar-bg: #2d2d2d;
        }
        
        [data-theme="sepia"] {
            --primary-color: #8b7355;
            --secondary-color: #a0826d;
            --bg-color: #f4ecd8;
            --text-color: #5c4a3a;
            --sidebar-bg: #faf5e8;
        }

        body.reader-dark {
            background: #1a1a1a;
        }

        body.reader-dark .reader-container {
            background: #2d2d2d;
        }

        body.reader-dark .toolbar {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
        }

        body.reader-dark .sidebar {
            background: #2d2d2d;
            border-left-color: #4a5568;
        }

        body.reader-sepia {
            background: #d4b896;
        }

        body.reader-sepia .reader-container {
            background: #f4ecd8;
        }

        body.reader-sepia .toolbar {
            background: linear-gradient(135deg, #c4a57b 0%, #a0826d 100%);
        }

        body.reader-sepia .sidebar {
            background: #faf5e8;
            border-left-color: #d4b896;
        }

        body.reader-night {
            background: #000000;
        }

        body.reader-night .reader-container {
            background: #1a1a1a;
        }

        body.reader-night .toolbar {
            background: linear-gradient(135deg, #1a1a1a 0%, #000000 100%);
        }

        body.reader-night .sidebar {
            background: #1a1a1a;
            border-left-color: #333;
        }

        body.reader-blue {
            background: #1a2332;
        }

        body.reader-blue .reader-container {
            background: #2c3e50;
        }

        body.reader-blue .toolbar {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
        }

        body.reader-blue .sidebar {
            background: #34495e;
            border-left-color: #3498db;
        }

        body.reader-blue .page-container {
            background: #ecf0f1;
            color: #2c3e50;
        }

        body.reader-blue #viewerArea {
            background: #34495e;
        }

        body.reader-green {
            background: #1b2e1f;
        }

        body.reader-green .reader-container {
            background: #27ae60;
        }

        body.reader-green .toolbar {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
        }

        body.reader-green .sidebar {
            background: #2ecc71;
            border-left-color: #27ae60;
        }

        body.reader-green .page-container {
            background: #f1f8e9;
            color: #1b5e20;
        }

        body.reader-green #viewerArea {
            background: #a5d6a7;
        }

        body.reader-purple {
            background: #2d1b3d;
        }

        body.reader-purple .reader-container {
            background: #4a2c5e;
        }

        body.reader-purple .toolbar {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
        }

        body.reader-purple .sidebar {
            background: #6c3483;
            border-left-color: #9b59b6;
        }

        body.reader-purple .page-container {
            background: #f3e5f5;
            color: #4a148c;
        }

        body.reader-purple #viewerArea {
            background: #5e3a6e;
        }

        body.reader-blue .modal-content,
        body.reader-blue .dictionary-popup,
        body.reader-blue .context-menu,
        body.reader-blue .annotation-tooltip,
        body.reader-blue .btn-close {
            background: #34495e;
            color: #ecf0f1;
            border-color: #3498db;
        }

        body.reader-green .modal-content,
        body.reader-green .dictionary-popup,
        body.reader-green .context-menu,
        body.reader-green .annotation-tooltip,
        body.reader-green .btn-close {
            background: #2ecc71;
            color: #1b5e20;
            border-color: #27ae60;
        }

        body.reader-purple .modal-content,
        body.reader-purple .dictionary-popup,
        body.reader-purple .context-menu,
        body.reader-purple .annotation-tooltip,
        body.reader-purple .btn-close {
            background: #6c3483;
            color: #f3e5f5;
            border-color: #9b59b6;
        }

        .sort-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .sort-btn {
            flex: 1;
            padding: 5px;
            font-size: 11px;
            border: 1px solid var(--primary-color);
            background: transparent;
            color: var(--text-color);
            border-radius: 4px;
            cursor: pointer;
        }

        .sort-btn.active {
            background: var(--primary-color);
            color: white;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            transition: all 0.3s;
            overflow: hidden;
        }
        
        .reader-container {
            background: var(--sidebar-bg);
            border-radius: 0;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .toolbar {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: white;
            padding: 10px 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            flex-shrink: 0;
        }
        
        .toolbar-section {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .toolbar button, .toolbar select, .toolbar input {
            border: none;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }
        
        .toolbar button {
            background: rgba(255,255,255,0.2);
            color: white;
        }
        
        .toolbar button:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }
        
        .toolbar button.active {
            background: rgba(255,255,255,0.4);
        }
        
        .toolbar select, .toolbar input {
            background: rgba(255,255,255,0.9);
            color: #333;
        }
        
        .content-wrapper {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        #viewerArea {
            flex: 1;
            background: var(--bg-color);
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
        }
        
        #viewerArea.fit-height-mode {
            overflow-y: hidden;
            padding: 0;
            align-items: center;
        }

        #viewerArea.single-page-mode, #viewerArea.double-page-mode {
            overflow-y: auto;
            overflow-x: auto;
        }
        
        .page-container {
            background: var(--sidebar-bg);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            margin: 0 auto;
            padding: 40px;
            color: var(--text-color);
            position: relative;
            width: 100%;
            max-width: 1200px;
        }
        
        .page-container.fit-width {
            width: 100%;
            max-width: none;
            margin: 0;
        }

        .page-container.document-style {
            padding: 40px;
            max-width: 900px;
        }

        .display-dark .page-container {
            background: #2d2d2d;
            color: #e0e0e0;
        }

        .display-sepia .page-container {
            background: #f4ecd8;
            color: #5c4a3a;
        }

        .display-night .page-container {
            background: #1a1a1a;
            color: #b0b0b0;
        }

        .display-dark #viewerArea {
            background: #1a1a1a;
        }

        .display-sepia #viewerArea {
            background: #e8dcc0;
        }

        .display-night #viewerArea {
            background: #000000;
        }

        body.reader-dark .page-container {
            background: #2d2d2d;
            color: #e0e0e0;
        }

        body.reader-sepia .page-container {
            background: #f4ecd8;
            color: #5c4a3a;
        }

        body.reader-night .page-container {
            background: #1a1a1a;
            color: #b0b0b0;
        }

        body.reader-dark #viewerArea {
            background: #1a1a1a;
        }

        body.reader-sepia #viewerArea {
            background: #e8dcc0;
        }

        body.reader-night #viewerArea {
            background: #000000;
        }

        body.reader-dark .modal-content,
        body.reader-dark .dictionary-popup,
        body.reader-dark .context-menu,
        body.reader-dark .annotation-tooltip {
            background: #2d2d2d;
            color: #e0e0e0;
            border-color: #4a5568;
        }

        body.reader-sepia .modal-content,
        body.reader-sepia .dictionary-popup,
        body.reader-sepia .context-menu,
        body.reader-sepia .annotation-tooltip {
            background: #faf5e8;
            color: #5c4a3a;
            border-color: #d4b896;
        }

        body.reader-night .modal-content,
        body.reader-night .dictionary-popup,
        body.reader-night .context-menu,
        body.reader-night .annotation-tooltip {
            background: #1a1a1a;
            color: #b0b0b0;
            border-color: #333;
        }

        .file-label {
            font-size: 10px;
            background: var(--primary-color);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            margin-right: 5px;
        }

        .page-break {
            page-break-after: always;
            break-after: page;
            margin: 40px 0;
            border-top: 2px dashed #ccc;
            padding-top: 40px;
        }
        
        .two-page-view {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            width: 100%;
        }
        
        .sidebar {
            width: 320px;
            background: var(--sidebar-bg);
            border-left: 1px solid #dee2e6;
            padding: 20px;
            overflow-y: auto;
            color: var(--text-color);
            flex-shrink: 0;
        }
        
        .sidebar h5 {
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
            margin-bottom: 15px;
            font-size: 16px;
        }
        
        .bookmark-item, .library-item, .toc-item {
            padding: 10px;
            margin: 8px 0;
            background: var(--bg-color);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }
        
        .bookmark-item:hover, .library-item:hover, .toc-item:hover {
            background: var(--primary-color);
            color: white;
            transform: translateX(5px);
        }
        
        .highlight {
            cursor: pointer;
            padding: 2px;
            border-radius: 2px;
        }
        
        .highlight-yellow { background: rgba(255, 255, 0, 0.4); }
        .highlight-green { background: rgba(0, 255, 0, 0.3); }
        .highlight-blue { background: rgba(0, 150, 255, 0.3); }
        .highlight-pink { background: rgba(255, 0, 150, 0.3); }
        
        .cursor-highlight {
            background: rgba(255, 255, 0, 0.3);
            cursor: pointer;
        }
        
        .stats-card {
            background: var(--bg-color);
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid var(--primary-color);
        }
        
        .stats-card h6 {
            color: var(--primary-color);
            margin: 0 0 5px 0;
            font-size: 14px;
        }
        
        .stats-card p {
            margin: 0;
            font-size: 24px;
            font-weight: bold;
            color: var(--text-color);
        }
        
        .tts-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--sidebar-bg);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            display: none;
            z-index: 1000;
            color: var(--text-color);
        }
        
        .dictionary-popup {
            position: fixed;
            background: var(--sidebar-bg);
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            max-width: 300px;
            z-index: 1000;
            display: none;
            color: var(--text-color);
        }
        
        canvas {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
        }
        
        .color-picker {
            display: inline-block;
            width: 30px;
            height: 30px;
            border-radius: 4px;
            cursor: pointer;
            margin: 0 5px;
            border: 2px solid transparent;
        }
        
        .color-picker:hover {
            border-color: var(--primary-color);
        }
        
        .recent-file {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .theme-selector {
            display: flex;
            gap: 10px;
        }
        
        .theme-option {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s;
        }
        
        .theme-option:hover, .theme-option.active {
            border-color: white;
            transform: scale(1.1);
        }
        
        .theme-light { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .theme-dark { background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%); }
        .theme-sepia { background: linear-gradient(135deg, #f4ecd8 0%, #d4b896 100%); }
        
        .page-info {
            color: white;
            font-weight: 500;
        }
        
        .progress-bar-custom {
            height: 4px;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
            margin-top: 10px;
            width: 100%;
        }
        
        .progress-fill {
            height: 100%;
            background: white;
            border-radius: 2px;
            transition: width 0.3s;
        }
        
        .tab-content {
            margin-top: 20px;
        }
        
        .nav-pills .nav-link {
            color: var(--text-color);
            border-radius: 6px;
            font-size: 14px;
            padding: 8px 12px;
        }
        
        .nav-pills .nav-link.active {
            background: var(--primary-color);
        }

        .welcome-screen {
            text-align: center;
            color: var(--text-color);
            padding: 50px 20px;
        }

        .welcome-screen i {
            color: var(--primary-color);
        }

        #contentContainer {
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }

        .page-canvas-wrapper {
            position: relative;
            display: inline-block;
        }

        .text-layer {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            line-height: 1.0;
            opacity: 1;
        }

        .text-layer > span {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
        }

        .text-layer ::selection {
            background: rgba(0, 100, 255, 0.3);
        }

        .search-highlight-temp {
            background: rgba(255, 255, 0, 0.6);
            padding: 2px 4px;
            border-radius: 2px;
            animation: pulse 1s ease-in-out 3;
        }

        @keyframes pulse {
            0%, 100% { background: rgba(255, 255, 0, 0.6); }
            50% { background: rgba(255, 255, 0, 0.9); }
        }

        .context-menu {
            position: fixed;
            background: var(--sidebar-bg);
            border: 1px solid var(--primary-color);
            border-radius: 8px;
            padding: 8px 0;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 10000;
            min-width: 200px;
            display: none;
        }

        .context-menu-item {
            padding: 10px 20px;
            cursor: pointer;
            color: var(--text-color);
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .context-menu-item:hover {
            background: var(--primary-color);
            color: white;
        }

        .context-menu-item i {
            width: 20px;
        }

        .context-menu-divider {
            height: 1px;
            background: #dee2e6;
            margin: 5px 0;
        }

        .annotation-marker {
            position: absolute;
            width: 24px;
            height: 24px;
            background: var(--primary-color);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            transition: transform 0.3s;
        }

        .annotation-marker:hover {
            transform: scale(1.2);
        }

        .annotation-tooltip {
            position: absolute;
            background: var(--sidebar-bg);
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            max-width: 300px;
            z-index: 1001;
            display: none;
            color: var(--text-color);
        }

        .highlight-deletable {
            position: relative;
            cursor: pointer;
        }

        .highlight-deletable:hover::after {
            content: '×';
            position: absolute;
            right: -15px;
            top: -8px;
            background: red;
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
        }
    </style>
</head>
<body data-theme="light">
    <div class="reader-container">
        <div class="toolbar">
            <div class="toolbar-section">
                <button onclick="openLibrary()" title="Library">
                    <i class="fas fa-book"></i>
                </button>
                <input type="file" id="fileInput" accept=".pdf,.epub,.doc,.docx" style="display:none" onchange="loadFile(event)">
                <button onclick="document.getElementById('fileInput').click()" title="Upload File">
                    <i class="fas fa-upload"></i>
                </button>
            </div>
            
            <div class="toolbar-section">
                <button onclick="previousPage()" title="Previous Page (←)">
                    <i class="fas fa-chevron-left"></i>
                </button>
                <input type="number" id="pageInput" min="1" style="width: 70px; text-align: center;" placeholder="Page" onchange="goToPage()">
                <span class="page-info" id="pageInfo">/ 0</span>
                <button onclick="nextPage()" title="Next Page (→)">
                    <i class="fas fa-chevron-right"></i>
                </button>
            </div>

            <div class="toolbar-section">
                <select id="viewMode" onchange="changeViewMode()" title="View Mode">
                    <option value="single">Single</option>
                    <option value="double">Double</option>
                    <option value="scroll">Scroll</option>
                </select>
                <select id="displayTheme" onchange="changeDisplayTheme()" title="Display Theme">
                    <option value="light">Light</option>
                    <option value="dark">Dark</option>
                    <option value="sepia">Sepia</option>
                    <option value="night">Night</option>
                    <option value="blue">Blue</option>
                    <option value="green">Green</option>
                    <option value="purple">Purple</option>
                </select>
            </div>

            <div class="toolbar-section">
                <button onclick="zoomIn()" title="Zoom In">
                    <i class="fas fa-search-plus"></i>
                </button>
                <button onclick="zoomOut()" title="Zoom Out">
                    <i class="fas fa-search-minus"></i>
                </button>
                <button onclick="fitToWidth()" title="Fit to Width">
                    <i class="fas fa-arrows-alt-h"></i>
                </button>
                <button onclick="fitToHeight()" title="Fit to Height">
                    <i class="fas fa-arrows-alt-v"></i>
                </button>
                <span class="page-info" id="zoomLevel">100%</span>
            </div>

            <div class="toolbar-section">
                <button onclick="toggleBookmark()" title="Bookmark">
                    <i class="fas fa-bookmark"></i>
                </button>
                <button id="highlightBtn" onclick="toggleHighlight()" title="Text Highlight">
                    <i class="fas fa-highlighter"></i>
                </button>
                <button id="cursorHighlightBtn" onclick="toggleCursorHighlight()" title="Cursor Highlight">
                    <i class="fas fa-mouse-pointer"></i>
                </button>
                <button id="annotateBtn" onclick="toggleAnnotationMode()" title="Add Annotation">
                    <i class="fas fa-sticky-note"></i>
                </button>
                <button onclick="clipSelectedText()" title="Clip to Notes">
                    <i class="fas fa-clipboard"></i>
                </button>
                <button onclick="defineSelectedWord()" title="Define Word">
                    <i class="fas fa-book-open"></i>
                </button>
                <button onclick="openSearch()" title="Search">
                    <i class="fas fa-search"></i>
                </button>
                <button onclick="toggleTTS()" title="Text-to-Speech">
                    <i class="fas fa-volume-up"></i>
                </button>
                <button onclick="openSidebar()" title="Menu">
                    <i class="fas fa-bars"></i>
                </button>
            </div>

            <div class="progress-bar-custom">
                <div class="progress-fill" id="progressBar"></div>
            </div>
        </div>

        <div class="content-wrapper">
            <div id="viewerArea">
                <div class="welcome-screen">
                    <i class="fas fa-book-open fa-5x mb-4"></i>
                    <h3>Welcome to Universal File Reader Pro</h3>
                    <p>Upload a file or select from the library to start reading</p>
                </div>
                <div class="dictionary-popup" id="dictionaryPopup"></div>
            </div>
            
            <div class="sidebar" id="sidebar" style="display: none;">
                <ul class="nav nav-pills mb-3" id="sidebarTabs" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" data-bs-toggle="pill" data-bs-target="#tocTab">TOC</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" data-bs-toggle="pill" data-bs-target="#bookmarksTab">
                            <i class="fas fa-bookmark"></i>
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" data-bs-toggle="pill" data-bs-target="#highlightsTab">
                            <i class="fas fa-highlighter"></i>
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" data-bs-toggle="pill" data-bs-target="#annotationsTab">
                            <i class="fas fa-sticky-note"></i>
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" data-bs-toggle="pill" data-bs-target="#notesTab">
                            <i class="fas fa-clipboard"></i>
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" data-bs-toggle="pill" data-bs-target="#statsTab">
                            <i class="fas fa-chart-bar"></i>
                        </button>
                    </li>
                </ul>
                
                <div class="tab-content">
                    <div class="tab-pane fade show active" id="tocTab">
                        <h5>Table of Contents</h5>
                        <div id="tocList"></div>
                    </div>
                    
                    <div class="tab-pane fade" id="bookmarksTab">
                        <h5>Bookmarks</h5>
                        <div class="sort-buttons">
                            <button class="sort-btn active" onclick="setSortMode('bookmarks', 'recent')">Recent</button>
                            <button class="sort-btn" onclick="setSortMode('bookmarks', 'position')">Position</button>
                        </div>
                        <button class="btn btn-sm btn-outline-danger w-100 mb-2" onclick="clearAllBookmarks()">
                            <i class="fas fa-trash"></i> Clear All
                        </button>
                        <div id="bookmarksList"></div>
                    </div>
                    
                    <div class="tab-pane fade" id="highlightsTab">
                        <h5>Highlights</h5>
                        <div class="sort-buttons">
                            <button class="sort-btn active" onclick="setSortMode('highlights', 'recent')">Recent</button>
                            <button class="sort-btn" onclick="setSortMode('highlights', 'position')">Position</button>
                        </div>
                        <button class="btn btn-sm btn-outline-danger w-100 mb-2" onclick="clearAllHighlights()">
                            <i class="fas fa-trash"></i> Clear All
                        </button>
                        <div id="highlightsList"></div>
                    </div>
                    
                    <div class="tab-pane fade" id="annotationsTab">
                        <h5>Annotations</h5>
                        <div class="sort-buttons">
                            <button class="sort-btn active" onclick="setSortMode('annotations', 'recent')">Recent</button>
                            <button class="sort-btn" onclick="setSortMode('annotations', 'position')">Position</button>
                        </div>
                        <button class="btn btn-sm btn-outline-danger w-100 mb-2" onclick="clearAllAnnotations()">
                            <i class="fas fa-trash"></i> Clear All
                        </button>
                        <div id="annotationsList"></div>
                    </div>
                    
                    <div class="tab-pane fade" id="notesTab">
                        <h5>Clipped Notes</h5>
                        <div class="sort-buttons">
                            <button class="sort-btn active" onclick="setSortMode('notes', 'recent')">Recent</button>
                            <button class="sort-btn" onclick="setSortMode('notes', 'position')">Position</button>
                        </div>
                        <button class="btn btn-sm btn-outline-danger w-100 mb-2" onclick="clearAllNotes()">
                            <i class="fas fa-trash"></i> Clear All
                        </button>
                        <div id="notesList"></div>
                    </div>
                    
                    <div class="tab-pane fade" id="statsTab">
                        <h5>Reading Statistics</h5>
                        <div class="stats-card">
                            <h6>Time Reading</h6>
                            <p id="readingTime">0m</p>
                        </div>
                        <div class="stats-card">
                            <h6>Pages Read</h6>
                            <p id="pagesRead">0</p>
                        </div>
                        <div class="stats-card">
                            <h6>Current Session</h6>
                            <p id="sessionTime">0m</p>
                        </div>
                        <div class="stats-card">
                            <h6>Progress</h6>
                            <p id="readingProgress">0%</p>
                        </div>
                        <button class="btn btn-sm btn-primary mt-3 w-100" onclick="exportStats()">
                            <i class="fas fa-download"></i> Export Stats
                        </button>
                        <button class="btn btn-sm btn-outline-danger mt-2 w-100" onclick="clearReadingStats()">
                            <i class="fas fa-trash"></i> Clear Stats
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- TTS Controls -->
    <div class="tts-controls" id="ttsControls">
        <h6 style="color: var(--primary-color);">Text-to-Speech</h6>
        <div class="d-flex gap-2 mb-2">
            <button class="btn btn-sm btn-primary" onclick="ttsPlay()">
                <i class="fas fa-play"></i>
            </button>
            <button class="btn btn-sm btn-warning" onclick="ttsPause()">
                <i class="fas fa-pause"></i>
            </button>
            <button class="btn btn-sm btn-danger" onclick="ttsStop()">
                <i class="fas fa-stop"></i>
            </button>
        </div>
        <label class="small">Speed</label>
        <input type="range" class="form-range" min="0.5" max="2" step="0.1" value="1" id="ttsSpeed">
        <label class="small">Pitch</label>
        <input type="range" class="form-range" min="0.5" max="2" step="0.1" value="1" id="ttsPitch">
    </div>

    <!-- Library Modal -->
    <div class="modal fade" id="libraryModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h5 class="modal-title"><i class="fas fa-book"></i> Library</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <h6>Recent Files</h6>
                    <div id="recentFilesList"></div>
                    <button class="btn btn-sm btn-outline-danger w-100 mt-2" onclick="clearRecentFiles()">
                        <i class="fas fa-trash"></i> Clear Recent Files
                    </button>
                    
                    <hr>
                    
                    <h6>Preloaded Books</h6>
                    <div id="libraryContent">
                        <!-- Add your preloaded files here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Search Modal -->
    <div class="modal fade" id="searchModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title"><i class="fas fa-search"></i> Search in Document</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <input type="text" class="form-control" id="searchInput" placeholder="Enter search term..." onkeypress="if(event.key==='Enter') performSearch()">
                    <div class="d-flex gap-2 mt-2" id="searchNavigation" style="display: none !important;">
                        <button class="btn btn-sm btn-secondary" onclick="previousSearchResult()">
                            <i class="fas fa-chevron-left"></i> Previous
                        </button>
                        <button class="btn btn-sm btn-secondary" onclick="nextSearchResult()">
                            Next <i class="fas fa-chevron-right"></i>
                        </button>
                        <span class="align-self-center" id="searchPosition"></span>
                    </div>
                    <div id="searchResults" class="mt-3"></div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-primary" onclick="performSearch()">Search</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Highlight Color Modal -->
    <div class="modal fade" id="highlightModal" tabindex="-1">
        <div class="modal-dialog modal-sm">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Select Highlight Color</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body text-center">
                    <div class="color-picker highlight-yellow" onclick="selectHighlightColor('yellow')"></div>
                    <div class="color-picker highlight-green" onclick="selectHighlightColor('green')"></div>
                    <div class="color-picker highlight-blue" onclick="selectHighlightColor('blue')"></div>
                    <div class="color-picker highlight-pink" onclick="selectHighlightColor('pink')"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal fade" id="settingsModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title"><i class="fas fa-cog"></i> Settings</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label class="form-label">Theme</label>
                        <div class="theme-selector">
                            <div class="theme-option theme-light active" onclick="changeTheme('light')" title="Light"></div>
                            <div class="theme-option theme-dark" onclick="changeTheme('dark')" title="Dark"></div>
                            <div class="theme-option theme-sepia" onclick="changeTheme('sepia')" title="Sepia"></div>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Font Size: <span id="fontSizeLabel">16px</span></label>
                        <input type="range" class="form-range" min="12" max="24" value="16" id="fontSizeSlider" oninput="changeFontSize(this.value)">
                    </div>
                    <div class="mb-3">
                        <label class="form-label">Line Spacing</label>
                        <select class="form-select" id="lineSpacingSelect" onchange="changeLineSpacing(this.value)">
                            <option value="1.5">Normal</option>
                            <option value="1.8">Comfortable</option>
                            <option value="2.0">Spacious</option>
                        </select>
                    </div>
                    <hr>
                    <button class="btn btn-primary w-100 mb-2" onclick="exportAllData()">
                        <i class="fas fa-download"></i> Export All Data
                    </button>
                    <button class="btn btn-outline-danger w-100" onclick="clearAllData()">
                        <i class="fas fa-trash"></i> Clear All Data
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" onclick="contextMenuAction('copy')">
            <i class="fas fa-copy"></i> Copy
        </div>
        <div class="context-menu-item" onclick="contextMenuAction('highlight')">
            <i class="fas fa-highlighter"></i> Highlight
        </div>
        <div class="context-menu-item" onclick="contextMenuAction('annotate')">
            <i class="fas fa-sticky-note"></i> Add Annotation
        </div>
        <div class="context-menu-item" onclick="contextMenuAction('clipToNotes')">
            <i class="fas fa-clipboard"></i> Clip to Notes
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" onclick="contextMenuAction('search')">
            <i class="fas fa-search"></i> Search Selected
        </div>
        <div class="context-menu-item" onclick="contextMenuAction('dictionary')">
            <i class="fas fa-book"></i> Define Word
        </div>
    </div>

    <!-- Annotation Modal -->
    <div class="modal fade" id="annotationModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title"><i class="fas fa-sticky-note"></i> Add Annotation</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <p class="text-muted">Page <span id="annotationPageNum"></span></p>
                    <div id="annotationContext" class="mb-2 p-2 bg-light rounded small"></div>
                    <textarea class="form-control" id="annotationText" rows="4" placeholder="Enter your annotation..."></textarea>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-primary" onclick="saveAnnotation()">Save Annotation</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Preloaded files configuration - ADD YOUR FILES HERE
        const PRELOADED_FILES = [
            {
                name: 'Scripture Memorization',
                path: '/assets/pdf/Scripture-Memorization.pdf',  // Replace with your actual file path
                type: 'pdf'
            },
            {
                name: 'Heart of Darkness',
                path: '/assets/epub/Conrad-Heart-of-Darkness.epub',  // Replace with your actual file path
                type: 'epub'
            },
            {
                name: 'Sample Document',
                path: '/path/to/sample3.docx',  // Replace with your actual file path
                type: 'docx'
            }
        ];

        // Global variables
        let currentPage = 1;
        let totalPages = 0;
        let currentFile = null;
        let currentFileName = '';
        let fileType = '';
        let viewMode = 'single';
        let zoomLevel = 1.0;
        let fitToWidthMode = false;
        let fitToHeightMode = false;
        let bookmarks = JSON.parse(localStorage.getItem('bookmarks') || '{}');
        let highlights = JSON.parse(localStorage.getItem('highlights') || '{}');
        let recentFiles = JSON.parse(localStorage.getItem('recentFiles') || '[]');
        let readingStats = JSON.parse(localStorage.getItem('readingStats') || '{"totalTime": 0, "pagesRead": {}, "sessions": []}');
        let pdfDoc = null;
        let documentContent = '';
        let highlightMode = false;
        let cursorHighlightMode = false;
        let selectedColor = 'yellow';
        let sessionStart = Date.now();
        let statsInterval = null;
        let ttsUtterance = null;
        let currentTheme = localStorage.getItem('theme') || 'light';
        let fileData = null;
        let currentHighlightedLine = null;
        let annotationMode = false;
        let annotations = JSON.parse(localStorage.getItem('annotations') || '{}');
        let clippedNotes = JSON.parse(localStorage.getItem('clippedNotes') || '{}');
        let contextMenuSelection = null;
        let displayTheme = 'light';
        let searchResults = [];
        let currentSearchIndex = -1;
        let sortModes = {
            bookmarks: 'recent',
            highlights: 'recent',
            annotations: 'recent',
            notes: 'recent'
        };
        
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Initialize
        document.body.setAttribute('data-theme', currentTheme);
        updateThemeSelector();
        loadPreloadedLibrary();

        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
            if (e.key === 'ArrowLeft') {
                previousPage();
            } else if (e.key === 'ArrowRight') {
                nextPage();
            }
        });

        // Mouse wheel navigation with scroll detection
        let scrollTimeout;
        let lastScrollPosition = 0;
        
        document.addEventListener('wheel', function(e) {
            if ((viewMode === 'single' || viewMode === 'double') && fileType === 'pdf') {
                const viewerArea = document.getElementById('viewerArea');
                
                // In fit to height mode, disable scrolling entirely
                if (fitToHeightMode) {
                    e.preventDefault();
                    if (e.deltaY > 0) {
                        nextPage();
                    } else if (e.deltaY < 0) {
                        previousPage();
                    }
                    return;
                }
                
                const atTop = viewerArea.scrollTop === 0;
                const atBottom = viewerArea.scrollTop + viewerArea.clientHeight >= viewerArea.scrollHeight - 5;
                
                if (e.deltaY > 0 && atBottom) {
                    // Scrolling down at bottom - next page and scroll to top
                    e.preventDefault();
                    nextPage();
                    setTimeout(() => {
                        viewerArea.scrollTop = 0;
                    }, 50);
                } else if (e.deltaY < 0 && atTop) {
                    // Scrolling up at top - previous page
                    e.preventDefault();
                    previousPage();
                }
                // Otherwise allow normal scrolling
            }
        }, { passive: false });

        // Context menu - simpler approach
        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            
            // Small delay to ensure selection is captured
            setTimeout(() => {
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();
                
                if (selectedText) {
                    contextMenuSelection = selectedText;
                    showContextMenu(e.clientX, e.clientY);
                }
            }, 10);
        });

        document.addEventListener('click', function(e) {
            if (!e.target.closest('.context-menu')) {
                hideContextMenu();
            }
            // Remove temporary search highlights
            document.querySelectorAll('.search-highlight-temp').forEach(el => {
                const parent = el.parentNode;
                parent.replaceChild(document.createTextNode(el.textContent), el);
                parent.normalize();
            });
        });

        function loadPreloadedLibrary() {
            const libraryContent = document.getElementById('libraryContent');
            libraryContent.innerHTML = '';
            
            PRELOADED_FILES.forEach(file => {
                const icons = {
                    'pdf': 'fa-file-pdf text-danger',
                    'epub': 'fa-book text-success',
                    'doc': 'fa-file-word text-primary',
                    'docx': 'fa-file-word text-primary'
                };
                
                const item = document.createElement('div');
                item.className = 'library-item';
                item.innerHTML = `
                    <div class="recent-file">
                        <i class="fas ${icons[file.type]}"></i>
                        <span>${file.name}</span>
                    </div>
                `;
                item.onclick = () => loadPreloadedFile(file);
                libraryContent.appendChild(item);
            });
        }

        async function loadPreloadedFile(fileInfo) {
            try {
                const response = await fetch(fileInfo.path);
                if (!response.ok) throw new Error('File not found');
                
                const blob = await response.blob();
                const file = new File([blob], fileInfo.name + '.' + fileInfo.type, { type: blob.type });
                
                currentFileName = file.name;
                currentFile = file;
                fileType = fileInfo.type;
                
                addToRecentFiles(file.name, fileType, fileInfo.path);
                startReadingSession();
                
                const reader = new FileReader();
                reader.onload = async function(e) {
                    fileData = e.target.result;
                    await loadFileByType(e.target.result, fileType);
                };
                reader.readAsArrayBuffer(file);
                
                document.getElementById('sidebar').style.display = 'block';
                bootstrap.Modal.getInstance(document.getElementById('libraryModal'))?.hide();
            } catch (error) {
                alert('Error loading file: ' + error.message + '\n\nMake sure the file path is correct and accessible.');
            }
        }

        async function loadFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            currentFile = file;
            currentFileName = file.name;
            const ext = file.name.split('.').pop().toLowerCase();
            fileType = ext;
            
            addToRecentFiles(file.name, ext, null);
            startReadingSession();
            
            const reader = new FileReader();
            reader.onload = async function(e) {
                fileData = e.target.result;
                await loadFileByType(e.target.result, ext);
            };
            reader.readAsArrayBuffer(file);
            
            document.getElementById('sidebar').style.display = 'block';
        }

        async function loadFileByType(data, type) {
            if (type === 'pdf') {
                await loadPDF(data);
            } else if (type === 'epub') {
                await loadEPUB(data);
            } else if (type === 'doc' || type === 'docx') {
                await loadDOCX(data);
            }
        }

        async function loadPDF(data) {
            try {
                pdfDoc = await pdfjsLib.getDocument({data: data}).promise;
                totalPages = pdfDoc.numPages;
                currentPage = 1;
                updatePageInfo();
                await renderPDFPage(currentPage);
                generateTOC();
            } catch (error) {
                alert('Error loading PDF: ' + error.message);
            }
        }

        async function renderPDFPage(pageNum) {
            const page = await pdfDoc.getPage(pageNum);
            let scale = zoomLevel * 1.5;
            
            if (fitToWidthMode) {
                scale = calculateFitToWidthScale(page);
            } else if (fitToHeightMode) {
                scale = calculateFitToHeightScale(page);
            }
            
            const viewport = page.getViewport({scale: scale});
            
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            
            await page.render({canvasContext: context, viewport: viewport}).promise;
            
            // Get text content for selection, search and TTS
            const textContent = await page.getTextContent();
            const textItems = textContent.items.map(item => item.str).join(' ');
            
            const viewerArea = document.getElementById('viewerArea');
            
            if (viewMode === 'single') {
                viewerArea.innerHTML = '';
                viewerArea.classList.add('single-page-mode');
                viewerArea.classList.remove('double-page-mode');
                
                const pageContainer = document.createElement('div');
                pageContainer.className = 'page-container';
                if (fitToWidthMode) pageContainer.classList.add('fit-width');
                
                const wrapper = document.createElement('div');
                wrapper.className = 'page-canvas-wrapper';
                wrapper.appendChild(canvas);
                
                // Create text layer for text selection
                const textLayerDiv = document.createElement('div');
                textLayerDiv.className = 'text-layer';
                textLayerDiv.style.width = viewport.width + 'px';
                textLayerDiv.style.height = viewport.height + 'px';
                
                // Render text layer
                pdfjsLib.renderTextLayer({
                    textContentSource: textContent,
                    container: textLayerDiv,
                    viewport: viewport,
                    textDivs: []
                });
                
                wrapper.appendChild(textLayerDiv);
                
                // Store text content as data attribute
                pageContainer.dataset.textContent = textItems;
                pageContainer.dataset.pageNumber = pageNum;
                
                pageContainer.appendChild(wrapper);
                viewerArea.appendChild(pageContainer);
                
                enableTextSelection();
                enableCursorHighlight();
                loadAnnotationsForPage(pageNum);
            } else if (viewMode === 'double' && pageNum < totalPages) {
                if (pageNum === currentPage) {
                    viewerArea.innerHTML = '';
                    viewerArea.classList.add('double-page-mode');
                    viewerArea.classList.remove('single-page-mode');
                    
                    const twoPageDiv = document.createElement('div');
                    twoPageDiv.className = 'two-page-view';
                    twoPageDiv.style.width = 'fit-content';
                    twoPageDiv.style.minWidth = (viewport.width * 2 + 60) + 'px';
                    
                    const container1 = document.createElement('div');
                    container1.className = 'page-container';
                    
                    const wrapper1 = document.createElement('div');
                    wrapper1.className = 'page-canvas-wrapper';
                    wrapper1.appendChild(canvas);
                    
                    const textLayerDiv1 = document.createElement('div');
                    textLayerDiv1.className = 'text-layer';
                    textLayerDiv1.style.width = viewport.width + 'px';
                    textLayerDiv1.style.height = viewport.height + 'px';
                    
                    pdfjsLib.renderTextLayer({
                        textContentSource: textContent,
                        container: textLayerDiv1,
                        viewport: viewport,
                        textDivs: []
                    });
                    
                    wrapper1.appendChild(textLayerDiv1);
                    container1.appendChild(wrapper1);
                    container1.dataset.textContent = textItems;
                    container1.dataset.pageNumber = pageNum;
                    twoPageDiv.appendChild(container1);
                    
                    // Render second page
                    const page2 = await pdfDoc.getPage(pageNum + 1);
                    const viewport2 = page2.getViewport({scale: scale});
                    const canvas2 = document.createElement('canvas');
                    const context2 = canvas2.getContext('2d');
                    canvas2.height = viewport2.height;
                    canvas2.width = viewport2.width;
                    await page2.render({canvasContext: context2, viewport: viewport2}).promise;
                    
                    const textContent2 = await page2.getTextContent();
                    const textItems2 = textContent2.items.map(item => item.str).join(' ');
                    
                    const container2 = document.createElement('div');
                    container2.className = 'page-container';
                    
                    const wrapper2 = document.createElement('div');
                    wrapper2.className = 'page-canvas-wrapper';
                    wrapper2.appendChild(canvas2);
                    
                    const textLayerDiv2 = document.createElement('div');
                    textLayerDiv2.className = 'text-layer';
                    textLayerDiv2.style.width = viewport2.width + 'px';
                    textLayerDiv2.style.height = viewport2.height + 'px';
                    
                    pdfjsLib.renderTextLayer({
                        textContentSource: textContent2,
                        container: textLayerDiv2,
                        viewport: viewport2,
                        textDivs: []
                    });
                    
                    wrapper2.appendChild(textLayerDiv2);
                    container2.appendChild(wrapper2);
                    container2.dataset.textContent = textItems2;
                    container2.dataset.pageNumber = pageNum + 1;
                    twoPageDiv.appendChild(container2);
                    
                    viewerArea.appendChild(twoPageDiv);
                    enableTextSelection();
                    enableCursorHighlight();
                    loadAnnotationsForPage(pageNum);
                    loadAnnotationsForPage(pageNum + 1);
                }
            } else if (viewMode === 'scroll') {
                viewerArea.classList.remove('single-page-mode', 'double-page-mode');
                
                if (pageNum === 1) {
                    viewerArea.innerHTML = '';
                    viewerArea.style.display = 'block';
                    viewerArea.style.justifyContent = 'flex-start';
                    viewerArea.style.alignItems = 'center';
                }
                
                const pageContainer = document.createElement('div');
                pageContainer.className = 'page-container';
                pageContainer.style.marginBottom = '30px';
                pageContainer.style.maxWidth = '900px';
                pageContainer.dataset.pageNumber = pageNum;
                
                const wrapper = document.createElement('div');
                wrapper.className = 'page-canvas-wrapper';
                wrapper.appendChild(canvas);
                
                const textLayerDiv = document.createElement('div');
                textLayerDiv.className = 'text-layer';
                textLayerDiv.style.width = viewport.width + 'px';
                textLayerDiv.style.height = viewport.height + 'px';
                
                pdfjsLib.renderTextLayer({
                    textContentSource: textContent,
                    container: textLayerDiv,
                    viewport: viewport,
                    textDivs: []
                });
                
                wrapper.appendChild(textLayerDiv);
                pageContainer.appendChild(wrapper);
                pageContainer.dataset.textContent = textItems;
                
                viewerArea.appendChild(pageContainer);
                
                if (pageNum < totalPages) {
                    await renderPDFPage(pageNum + 1);
                } else {
                    enableTextSelection();
                    enableCursorHighlight();
                    loadAnnotationsForPage(pageNum);
                }
            }
            
            trackPageRead(pageNum);
        }

        function calculateFitToWidthScale(page) {
            const viewerArea = document.getElementById('viewerArea');
            const availableWidth = viewerArea.clientWidth - 120; // Account for padding
            const viewport = page.getViewport({scale: 1});
            return availableWidth / viewport.width;
        }

        function calculateFitToHeightScale(page) {
            const viewerArea = document.getElementById('viewerArea');
            const availableHeight = viewerArea.clientHeight - 60; // Account for padding
            const viewport = page.getViewport({scale: 1});
            return availableHeight / viewport.height;
        }

        async function loadEPUB(data) {
            try {
                const zip = await JSZip.loadAsync(data);
                
                // Find the content.opf file to get the reading order
                let opfPath = null;
                const containerXml = await zip.file('META-INF/container.xml').async('string');
                const parser = new DOMParser();
                const containerDoc = parser.parseFromString(containerXml, 'text/xml');
                const rootfile = containerDoc.querySelector('rootfile');
                if (rootfile) {
                    opfPath = rootfile.getAttribute('full-path');
                }
                
                if (!opfPath) {
                    throw new Error('Could not find content.opf');
                }
                
                // Get the directory path
                const opfDir = opfPath.substring(0, opfPath.lastIndexOf('/') + 1);
                
                // Read content.opf
                const opfContent = await zip.file(opfPath).async('string');
                const opfDoc = parser.parseFromString(opfContent, 'text/xml');
                
                // Get spine items (reading order)
                const spine = opfDoc.querySelector('spine');
                const itemrefs = spine ? Array.from(spine.querySelectorAll('itemref')) : [];
                
                // Get manifest items
                const manifest = opfDoc.querySelector('manifest');
                const items = manifest ? Array.from(manifest.querySelectorAll('item')) : [];
                
                // Build ordered list of content files
                const contentFiles = [];
                itemrefs.forEach(itemref => {
                    const idref = itemref.getAttribute('idref');
                    const item = items.find(i => i.getAttribute('id') === idref);
                    if (item) {
                        const href = item.getAttribute('href');
                        contentFiles.push(opfDir + href);
                    }
                });
                
                // If no spine found, fall back to finding HTML files
                if (contentFiles.length === 0) {
                    const files = Object.keys(zip.files);
                    const htmlFiles = files.filter(f => 
                        (f.endsWith('.html') || f.endsWith('.xhtml')) && 
                        !f.includes('nav.') && 
                        !f.includes('toc.')
                    ).sort();
                    contentFiles.push(...htmlFiles);
                }
                
                // Load all content
                let content = '';
                for (let file of contentFiles) {
                    try {
                        const text = await zip.file(file).async('string');
                        // Remove XML declarations and extract body content
                        const cleanText = text.replace(/<\?xml[^?]*\?>/g, '');
                        const bodyMatch = cleanText.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
                        if (bodyMatch) {
                            content += bodyMatch[1] + '<hr style="margin: 40px 0; border: none; border-top: 2px solid #ddd;">';
                        } else {
                            content += cleanText + '<hr style="margin: 40px 0; border: none; border-top: 2px solid #ddd;">';
                        }
                    } catch (e) {
                        console.log('Could not load file: ' + file);
                    }
                }
                
                if (!content.trim()) {
                    throw new Error('No content found in EPUB');
                }
                
                documentContent = content;
                totalPages = 1;
                currentPage = 1;
                
                const viewerArea = document.getElementById('viewerArea');
                viewerArea.innerHTML = '';
                
                const pageContainer = document.createElement('div');
                pageContainer.className = 'page-container document-style';
                if (fitToWidthMode) pageContainer.classList.add('fit-width');
                
                const contentDiv = document.createElement('div');
                contentDiv.id = 'contentContainer';
                contentDiv.style.fontFamily = 'Georgia, serif';
                contentDiv.style.fontSize = '16px';
                contentDiv.style.lineHeight = '1.6';
                
                // Split content by horizontal rules or chapter markers to create pages
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = content;
                const sections = content.split(/<hr[^>]*>/gi);
                
                if (sections.length > 1) {
                    totalPages = sections.length;
                    sections.forEach((section, index) => {
                        const pageDiv = document.createElement('div');
                        pageDiv.className = 'page-break';
                        pageDiv.dataset.pageNumber = index + 1;
                        pageDiv.innerHTML = section;
                        contentDiv.appendChild(pageDiv);
                    });
                } else {
                    contentDiv.innerHTML = content;
                    totalPages = 1;
                }
                
                pageContainer.appendChild(contentDiv);
                viewerArea.appendChild(pageContainer);
                
                updatePageInfo();
                enableTextSelection();
                enableCursorHighlight();
                generateTOC();
                loadAnnotationsForPage(1);
                applyHighlightsToPage(1);
            } catch (e) {
                alert('Error loading EPUB file: ' + e.message);
                console.error(e);
            }
        }

        async function loadDOCX(data) {
            try {
                const result = await mammoth.convertToHtml({arrayBuffer: data});
                documentContent = result.value;
                totalPages = 1;
                currentPage = 1;
                
                const viewerArea = document.getElementById('viewerArea');
                viewerArea.innerHTML = '';
                
                const pageContainer = document.createElement('div');
                pageContainer.className = 'page-container document-style';
                if (fitToWidthMode) pageContainer.classList.add('fit-width');
                
                const contentDiv = document.createElement('div');
                contentDiv.id = 'contentContainer';
                contentDiv.style.fontFamily = "'Times New Roman', serif";
                contentDiv.style.fontSize = '16px';
                contentDiv.style.lineHeight = '1.6';
                
                // Try to detect page breaks in DOCX
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = result.value;
                
                // Look for page break indicators
                const pageBreakElements = tempDiv.querySelectorAll('[style*="page-break"]');
                if (pageBreakElements.length > 0) {
                    totalPages = pageBreakElements.length + 1;
                }
                
                contentDiv.innerHTML = result.value;
                
                pageContainer.appendChild(contentDiv);
                viewerArea.appendChild(pageContainer);
                
                updatePageInfo();
                enableTextSelection();
                enableCursorHighlight();
                generateTOC();
                loadAnnotationsForPage(1);
                applyHighlightsToPage(1);
            } catch (e) {
                alert('Error loading DOCX file: ' + e.message);
            }
        }

        function enableTextSelection() {
            setTimeout(() => {
                const container = document.getElementById('contentContainer');
                if (!container) return;
                
                container.addEventListener('mouseup', handleTextSelection);
                container.addEventListener('dblclick', handleDoubleClick);
            }, 100);
        }

        function enableCursorHighlight() {
            if (!cursorHighlightMode) return;
            
            setTimeout(() => {
                const containers = document.querySelectorAll('.page-container, #contentContainer');
                containers.forEach(container => {
                    const elements = container.querySelectorAll('p, div, span, h1, h2, h3, h4, h5, h6');
                    elements.forEach(el => {
                        if (el.children.length === 0 && el.textContent.trim()) {
                            el.addEventListener('mouseenter', function() {
                                if (cursorHighlightMode && currentHighlightedLine !== this) {
                                    if (currentHighlightedLine) {
                                        currentHighlightedLine.classList.remove('cursor-highlight');
                                    }
                                    this.classList.add('cursor-highlight');
                                    currentHighlightedLine = this;
                                }
                            });
                        }
                    });
                });
            }, 100);
        }

        function toggleCursorHighlight() {
            cursorHighlightMode = !cursorHighlightMode;
            const btn = document.getElementById('cursorHighlightBtn');
            
            if (cursorHighlightMode) {
                btn.classList.add('active');
                enableCursorHighlight();
            } else {
                btn.classList.remove('active');
                if (currentHighlightedLine) {
                    currentHighlightedLine.classList.remove('cursor-highlight');
                    currentHighlightedLine = null;
                }
            }
        }

        function handleTextSelection() {
            const selection = window.getSelection();
            const text = selection.toString().trim();
            
            if (text && highlightMode && selection.rangeCount > 0) {
                highlightSelectedText(selection);
            }
        }

        function handleDoubleClick(e) {
            const selection = window.getSelection();
            const word = selection.toString().trim();
            
            if (word && word.split(' ').length === 1) {
                showDictionary(word, e.clientX, e.clientY);
            }
        }

        function highlightSelectedText(selection) {
            if (selection.rangeCount === 0) return;
            
            const range = selection.getRangeAt(0);
            const span = document.createElement('span');
            span.className = `highlight highlight-${selectedColor}`;
            span.dataset.highlightId = Date.now();
            
            try {
                range.surroundContents(span);
                
                const fileKey = currentFileName || 'current';
                if (!highlights[fileKey]) highlights[fileKey] = [];
                
                highlights[fileKey].push({
                    page: currentPage,
                    text: selection.toString(),
                    color: selectedColor,
                    timestamp: new Date().toISOString(),
                    id: span.dataset.highlightId
                });
                
                saveData('highlights', highlights);
                updateHighlightsList();
                selection.removeAllRanges();
            } catch (e) {
                console.log('Cannot highlight: ' + e.message);
            }
        }

        function loadHighlightsForPage(page) {
            const fileKey = currentFileName || 'current';
            const pageHighlights = highlights[fileKey]?.filter(h => h.page === page) || [];
            // Highlights are already embedded in the DOM from previous sessions
        }

        function showDictionary(word, x, y) {
            const popup = document.getElementById('dictionaryPopup');
            popup.innerHTML = `
                <button type="button" class="btn-close float-end" onclick="closeDictionary()"></button>
                <h6 style="color: var(--primary-color);">${word}</h6>
                <p class="small mb-2">Loading definition...</p>
            `;
            popup.style.display = 'block';
            popup.style.left = Math.min(x, window.innerWidth - 320) + 'px';
            popup.style.top = Math.min(y - 100, window.innerHeight - 200) + 'px';
            
            fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`)
                .then(res => res.json())
                .then(data => {
                    if (data[0]) {
                        const meaning = data[0].meanings[0];
                        popup.innerHTML = `
                            <button type="button" class="btn-close float-end" onclick="closeDictionary()"></button>
                            <h6 style="color: var(--primary-color);">${word}</h6>
                            <p class="small mb-1"><em>${meaning.partOfSpeech}</em></p>
                            <p class="small">${meaning.definitions[0].definition}</p>
                            ${data[0].phonetics[0]?.audio ? `<button class="btn btn-sm btn-primary" onclick="playPronunciation('${data[0].phonetics[0].audio}')">
                                <i class="fas fa-volume-up"></i> Pronounce
                            </button>` : ''}
                        `;
                    }
                })
                .catch(() => {
                    popup.innerHTML = `
                        <button type="button" class="btn-close float-end" onclick="closeDictionary()"></button>
                        <h6 style="color: var(--primary-color);">${word}</h6>
                        <p class="small text-muted">Definition not found</p>
                    `;
                });
        }

        function closeDictionary() {
            document.getElementById('dictionaryPopup').style.display = 'none';
        }

        function playPronunciation(url) {
            new Audio(url).play();
        }

        function toggleHighlight() {
            highlightMode = !highlightMode;
            const btn = document.getElementById('highlightBtn');
            
            if (highlightMode) {
                btn.classList.add('active');
                const modal = new bootstrap.Modal(document.getElementById('highlightModal'));
                modal.show();
            } else {
                btn.classList.remove('active');
            }
        }

        function selectHighlightColor(color) {
            selectedColor = color;
            bootstrap.Modal.getInstance(document.getElementById('highlightModal')).hide();
        }

        function updateHighlightsList() {
            const list = document.getElementById('highlightsList');
            list.innerHTML = '';
            
            const fileKey = currentFileName || 'current';
            const fileHighlights = highlights[fileKey] || [];
            
            if (fileHighlights.length === 0) {
                list.innerHTML = '<p class="text-muted small">No highlights yet</p>';
                return;
            }
            
            fileHighlights.forEach((h, idx) => {
                const item = document.createElement('div');
                item.className = 'bookmark-item';
                item.innerHTML = `
                    <div style="flex: 1;">
                        <span class="highlight highlight-${h.color}" style="padding: 2px 8px; border-radius: 3px;">
                            ${h.text.substring(0, 40)}...
                        </span>
                        <small class="d-block text-muted">Page ${h.page}</small>
                    </div>
                    <button class="btn btn-sm btn-danger" onclick="event.stopPropagation(); removeHighlight('${h.id}');">
                        <i class="fas fa-times"></i>
                    </button>
                `;
                item.onclick = (e) => {
                    if (!e.target.closest('button')) {
                        jumpToPage(h.page, h.text);
                    }
                };
                list.appendChild(item);
            });
        }

        function removeHighlight(highlightId) {
            deleteHighlightById(highlightId);
        }

        function toggleTTS() {
            const controls = document.getElementById('ttsControls');
            controls.style.display = controls.style.display === 'none' ? 'block' : 'none';
        }

        function ttsPlay() {
            if ('speechSynthesis' in window) {
                let text = '';
                
                // Get text from current page
                if (fileType === 'pdf') {
                    const containers = document.querySelectorAll('.page-container');
                    containers.forEach(container => {
                        text += container.dataset.textContent + ' ';
                    });
                } else {
                    const container = document.getElementById('contentContainer');
                    text = container ? container.innerText : '';
                }
                
                if (text.trim()) {
                    window.speechSynthesis.cancel(); // Stop any ongoing speech
                    ttsUtterance = new SpeechSynthesisUtterance(text);
                    ttsUtterance.rate = parseFloat(document.getElementById('ttsSpeed').value);
                    ttsUtterance.pitch = parseFloat(document.getElementById('ttsPitch').value);
                    window.speechSynthesis.speak(ttsUtterance);
                } else {
                    alert('No text content found on this page');
                }
            } else {
                alert('Text-to-speech not supported in this browser');
            }
        }

        function ttsPause() {
            if (window.speechSynthesis.speaking && !window.speechSynthesis.paused) {
                window.speechSynthesis.pause();
            } else if (window.speechSynthesis.paused) {
                window.speechSynthesis.resume();
            }
        }

        function ttsStop() {
            window.speechSynthesis.cancel();
        }

        function generateTOC() {
            const tocList = document.getElementById('tocList');
            tocList.innerHTML = '';
            
            if (fileType === 'pdf') {
                // Simple page-based TOC for PDFs
                const step = Math.max(1, Math.floor(totalPages / 20));
                for (let i = 1; i <= totalPages; i += step) {
                    const item = document.createElement('div');
                    item.className = 'toc-item';
                    item.innerHTML = `Page ${i}`;
                    item.onclick = () => {
                        jumpToPage(i);
                    };
                    tocList.appendChild(item);
                }
            } else {
                // Extract headings for EPUB/DOCX
                setTimeout(() => {
                    const container = document.getElementById('contentContainer');
                    if (container) {
                        const headings = container.querySelectorAll('h1, h2, h3, h4, h5, h6');
                        if (headings.length > 0) {
                            headings.forEach((heading) => {
                                const item = document.createElement('div');
                                item.className = 'toc-item';
                                const level = parseInt(heading.tagName[1]);
                                item.style.paddingLeft = ((level - 1) * 15) + 'px';
                                item.innerHTML = heading.textContent.substring(0, 50);
                                item.onclick = () => {
                                    heading.scrollIntoView({behavior: 'smooth', block: 'start'});
                                };
                                tocList.appendChild(item);
                            });
                        } else {
                            tocList.innerHTML = '<p class="text-muted small">No headings found</p>';
                        }
                    }
                }, 500);
            }
        }

        function startReadingSession() {
            sessionStart = Date.now();
            if (statsInterval) clearInterval(statsInterval);
            
            statsInterval = setInterval(updateStats, 1000);
        }

        function updateStats() {
            const sessionTime = Math.floor((Date.now() - sessionStart) / 60000);
            document.getElementById('sessionTime').textContent = sessionTime + 'm';
            
            readingStats.totalTime += 1000;
            const totalMinutes = Math.floor(readingStats.totalTime / 60000);
            document.getElementById('readingTime').textContent = totalMinutes + 'm';
            
            const fileKey = currentFileName || 'current';
            if (!readingStats.pagesRead[fileKey]) {
                readingStats.pagesRead[fileKey] = {};
            }
            
            const pagesReadCount = Object.keys(readingStats.pagesRead[fileKey] || {}).length;
            document.getElementById('pagesRead').textContent = pagesReadCount;
            
            const progress = totalPages > 0 ? Math.round((currentPage / totalPages) * 100) : 0;
            document.getElementById('readingProgress').textContent = progress + '%';
            
            saveData('readingStats', readingStats);
        }

        function trackPageRead(page) {
            const fileKey = currentFileName || 'current';
            if (!readingStats.pagesRead[fileKey]) {
                readingStats.pagesRead[fileKey] = {};
            }
            if (!readingStats.pagesRead[fileKey][page]) {
                readingStats.pagesRead[fileKey][page] = true;
            }
        }

        function changeTheme(theme) {
            currentTheme = theme;
            document.body.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            updateThemeSelector();
        }

        function updateThemeSelector() {
            document.querySelectorAll('.theme-option').forEach(opt => {
                opt.classList.remove('active');
            });
            document.querySelector(`.theme-${currentTheme}`)?.classList.add('active');
        }

        function addToRecentFiles(name, type, path) {
            const file = {
                name: name,
                type: type,
                path: path,
                timestamp: new Date().toISOString()
            };
            
            recentFiles = recentFiles.filter(f => f.name !== name);
            recentFiles.unshift(file);
            recentFiles = recentFiles.slice(0, 10);
            
            saveData('recentFiles', recentFiles);
            updateRecentFilesList();
        }

        function updateRecentFilesList() {
            const list = document.getElementById('recentFilesList');
            list.innerHTML = '';
            
            if (recentFiles.length === 0) {
                list.innerHTML = '<p class="text-muted small">No recent files</p>';
                return;
            }
            
            recentFiles.forEach(file => {
                const icons = {
                    'pdf': 'fa-file-pdf text-danger',
                    'epub': 'fa-book text-success',
                    'doc': 'fa-file-word text-primary',
                    'docx': 'fa-file-word text-primary'
                };
                
                const item = document.createElement('div');
                item.className = 'library-item';
                item.innerHTML = `
                    <div class="recent-file">
                        <i class="fas ${icons[file.type] || 'fa-file'}"></i>
                        <div>
                            <div>${file.name}</div>
                            <small class="text-muted">${new Date(file.timestamp).toLocaleDateString()}</small>
                        </div>
                    </div>
                `;
                
                // Only clickable if it's a preloaded file with a path
                if (file.path) {
                    item.style.cursor = 'pointer';
                    item.onclick = () => {
                        const fileInfo = PRELOADED_FILES.find(f => f.path === file.path) || {
                            name: file.name.replace(/\.[^/.]+$/, ""),
                            path: file.path,
                            type: file.type
                        };
                        loadPreloadedFile(fileInfo);
                    };
                } else {
                    item.style.opacity = '0.6';
                    item.title = 'User-uploaded file - please upload again to view';
                }
                
                list.appendChild(item);
            });
        }

        function exportAllData() {
            const data = {
                bookmarks: bookmarks,
                highlights: highlights,
                stats: readingStats,
                theme: currentTheme,
                recentFiles: recentFiles
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'reader-data-' + new Date().toISOString().split('T')[0] + '.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportStats() {
            try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                
                doc.setFontSize(20);
                doc.text('Reading Statistics', 20, 20);
                
                doc.setFontSize(12);
                const totalMinutes = Math.floor(readingStats.totalTime / 60000);
                doc.text(`Total Reading Time: ${totalMinutes} minutes`, 20, 40);
                
                let totalPagesRead = 0;
                Object.values(readingStats.pagesRead).forEach(filePages => {
                    totalPagesRead += Object.keys(filePages).length;
                });
                doc.text(`Total Pages Read: ${totalPagesRead}`, 20, 50);
                
                const fileKey = currentFileName || 'current';
                const fileBookmarks = bookmarks[fileKey] || [];
                const fileHighlights = highlights[fileKey] || [];
                doc.text(`Current File Bookmarks: ${fileBookmarks.length}`, 20, 60);
                doc.text(`Current File Highlights: ${fileHighlights.length}`, 20, 70);
                
                doc.save('reading-stats-' + new Date().toISOString().split('T')[0] + '.pdf');
            } catch (error) {
                alert('Error exporting stats. Please try again.');
            }
        }

        function clearAllData() {
            if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
                localStorage.clear();
                bookmarks = {};
                highlights = {};
                recentFiles = [];
                readingStats = {totalTime: 0, pagesRead: {}, sessions: []};
                alert('All data cleared');
                location.reload();
            }
        }

        function saveData(key, data) {
            try {
                localStorage.setItem(key, JSON.stringify(data));
            } catch (e) {
                console.error('Error saving to localStorage:', e);
            }
        }

        function previousPage() {
            if (currentPage > 1) {
                currentPage--;
                if (viewMode === 'double' && currentPage > 1) currentPage--;
                renderCurrentPage();
            }
        }

        function nextPage() {
            if (currentPage < totalPages) {
                currentPage++;
                if (viewMode === 'double' && currentPage < totalPages) currentPage++;
                renderCurrentPage();
            }
        }

        function goToPage() {
            const pageNum = parseInt(document.getElementById('pageInput').value);
            if (pageNum >= 1 && pageNum <= totalPages) {
                currentPage = pageNum;
                renderCurrentPage();
            }
        }

        async function renderCurrentPage() {
            if (fileType === 'pdf' && pdfDoc) {
                await renderPDFPage(currentPage);
            }
            updatePageInfo();
        }

        function updatePageInfo() {
            document.getElementById('pageInfo').textContent = `/ ${totalPages}`;
            document.getElementById('pageInput').value = currentPage;
            document.getElementById('pageInput').max = totalPages;
            
            const progress = totalPages > 0 ? (currentPage / totalPages) * 100 : 0;
            document.getElementById('progressBar').style.width = progress + '%';
        }

        function changeViewMode() {
            viewMode = document.getElementById('viewMode').value;
            if (fileType === 'pdf' && pdfDoc) {
                currentPage = 1; // Reset to first page when changing views
                renderCurrentPage();
            }
        }

        function zoomIn() {
            fitToWidthMode = false;
            fitToHeightMode = false;
            
            const viewerArea = document.getElementById('viewerArea');
            viewerArea.classList.remove('fit-height-mode');
            
            zoomLevel += 0.2;
            document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';
            if (fileType === 'pdf' && pdfDoc) {
                renderCurrentPage();
            } else {
                applyZoomToContent();
            }
        }

        function zoomOut() {
            if (zoomLevel > 0.4) {
                fitToWidthMode = false;
                fitToHeightMode = false;
                
                const viewerArea = document.getElementById('viewerArea');
                viewerArea.classList.remove('fit-height-mode');
                
                zoomLevel -= 0.2;
                document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';
                if (fileType === 'pdf' && pdfDoc) {
                    renderCurrentPage();
                } else {
                    applyZoomToContent();
                }
            }
        }

        function fitToWidth() {
            fitToWidthMode = !fitToWidthMode;
            fitToHeightMode = false;
            
            if (fitToWidthMode) {
                document.getElementById('zoomLevel').textContent = 'Fit W';
                if (fileType === 'pdf' && pdfDoc) {
                    renderCurrentPage();
                } else {
                    const containers = document.querySelectorAll('.page-container');
                    containers.forEach(c => c.classList.add('fit-width'));
                }
            } else {
                document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';
                if (fileType === 'pdf' && pdfDoc) {
                    renderCurrentPage();
                } else {
                    const containers = document.querySelectorAll('.page-container');
                    containers.forEach(c => c.classList.remove('fit-width'));
                }
            }
        }

        function fitToHeight() {
            fitToHeightMode = !fitToHeightMode;
            fitToWidthMode = false;
            
            const viewerArea = document.getElementById('viewerArea');
            
            if (fitToHeightMode) {
                document.getElementById('zoomLevel').textContent = 'Fit H';
                viewerArea.classList.add('fit-height-mode');
                if (fileType === 'pdf' && pdfDoc) {
                    renderCurrentPage();
                }
            } else {
                document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';
                viewerArea.classList.remove('fit-height-mode');
                if (fileType === 'pdf' && pdfDoc) {
                    renderCurrentPage();
                }
            }
        }

        function changeDisplayTheme(theme) {
            if (!theme) {
                theme = document.getElementById('displayTheme').value;
            }
            
            displayTheme = theme;
            const body = document.body;
            
            // Remove ALL theme classes first
            body.classList.remove('reader-dark', 'reader-sepia', 'reader-night', 'reader-blue', 'reader-green', 'reader-purple');
            
            // Add selected theme class
            if (theme !== 'light') {
                body.classList.add(`reader-${theme}`);
            }
            
            localStorage.setItem('displayTheme', theme);
        }

        function clipSelectedText() {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            
            if (!selectedText) {
                alert('Please select some text first');
                return;
            }
            
            const fileKey = currentFileName || 'current';
            if (!clippedNotes[fileKey]) clippedNotes[fileKey] = [];
            
            clippedNotes[fileKey].push({
                page: currentPage,
                text: selectedText,
                fileName: currentFileName,
                timestamp: new Date().toISOString()
            });
            
            saveData('clippedNotes', clippedNotes);
            updateNotesList();
            selection.removeAllRanges();
        }

        function defineSelectedWord() {
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            
            if (!selectedText) {
                alert('Please select a word first');
                return;
            }
            
            const word = selectedText.split(' ')[0];
            showDictionary(word, window.innerWidth / 2, window.innerHeight / 2);
        }

        function setSortMode(type, mode) {
            sortModes[type] = mode;
            
            // Update button states
            const parent = event.target.parentElement;
            parent.querySelectorAll('.sort-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Refresh the list
            switch(type) {
                case 'bookmarks':
                    updateBookmarksList();
                    break;
                case 'highlights':
                    updateHighlightsList();
                    break;
                case 'annotations':
                    updateAnnotationsList();
                    break;
                case 'notes':
                    updateNotesList();
                    break;
            }
        }

        function updateNotesList() {
            const list = document.getElementById('notesList');
            list.innerHTML = '';
            
            // Show all notes from all files
            let allNotes = [];
            Object.keys(clippedNotes).forEach(fileKey => {
                clippedNotes[fileKey].forEach((note, idx) => {
                    allNotes.push({ ...note, fileKey, idx });
                });
            });
            
            if (allNotes.length === 0) {
                list.innerHTML = '<p class="text-muted small">No clipped notes yet</p>';
                return;
            }
            
            // Sort based on mode
            if (sortModes.notes === 'recent') {
                allNotes.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            } else {
                allNotes.sort((a, b) => a.page - b.page);
            }
            
            allNotes.forEach(note => {
                const item = document.createElement('div');
                item.className = 'bookmark-item';
                item.style.flexDirection = 'column';
                item.style.alignItems = 'flex-start';
                item.style.cursor = 'pointer';
                item.innerHTML = `
                    <div class="d-flex align-items-center gap-2 mb-1">
                        <span class="file-label">${note.fileName || 'Unknown'}</span>
                        <small class="text-muted">Page ${note.page}</small>
                    </div>
                    <p class="mb-0">${note.text.substring(0, 100)}...</p>
                    <button class="btn btn-sm btn-danger mt-2" onclick="event.stopPropagation(); deleteNote('${note.fileKey}', ${note.idx})">
                        <i class="fas fa-times"></i> Delete
                    </button>
                `;
                item.onclick = (e) => {
                    if (!e.target.closest('button')) {
                        if (note.fileKey !== (currentFileName || 'current')) {
                            alert('This note is from a different document: ' + note.fileName);
                        } else {
                            jumpToPage(note.page, note.text);
                        }
                    }
                };
                list.appendChild(item);
            });
        }

        function deleteNote(fileKey, idx) {
            if (clippedNotes[fileKey]) {
                clippedNotes[fileKey].splice(idx, 1);
                saveData('clippedNotes', clippedNotes);
                updateNotesList();
            }
        }

        function clearAllNotes() {
            if (confirm('Clear all clipped notes for this file?')) {
                const fileKey = currentFileName || 'current';
                if (clippedNotes[fileKey]) {
                    clippedNotes[fileKey] = [];
                    saveData('clippedNotes', clippedNotes);
                    updateNotesList();
                }
            }
        }

        function clearRecentFiles() {
            if (confirm('Clear all recent files?')) {
                recentFiles = [];
                saveData('recentFiles', recentFiles);
                updateRecentFilesList();
            }
        }

        function applyHighlightsToPage(page) {
            const fileKey = currentFileName || 'current';
            const pageHighlights = highlights[fileKey]?.filter(h => h.page === page) || [];
            
            // For EPUB/DOCX, try to re-apply highlights
            if (fileType !== 'pdf' && pageHighlights.length > 0) {
                const container = document.getElementById('contentContainer');
                if (container) {
                    pageHighlights.forEach(h => {
                        try {
                            const text = h.text;
                            const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null, false);
                            const textNodes = [];
                            let node;
                            while (node = walker.nextNode()) {
                                if (node.textContent.includes(text)) {
                                    textNodes.push(node);
                                }
                            }
                            
                            textNodes.forEach(textNode => {
                                const content = textNode.textContent;
                                if (content.includes(text)) {
                                    const span = document.createElement('span');
                                    const parts = content.split(text);
                                    span.appendChild(document.createTextNode(parts[0]));
                                    
                                    const highlightSpan = document.createElement('span');
                                    highlightSpan.className = `highlight highlight-${h.color} highlight-deletable`;
                                    highlightSpan.dataset.highlightId = h.id;
                                    highlightSpan.textContent = text;
                                    highlightSpan.addEventListener('click', function(e) {
                                        e.stopPropagation();
                                        if (confirm('Delete this highlight?')) {
                                            deleteHighlightById(h.id);
                                        }
                                    });
                                    span.appendChild(highlightSpan);
                                    span.appendChild(document.createTextNode(parts.slice(1).join(text)));
                                    
                                    textNode.parentNode.replaceChild(span, textNode);
                                }
                            });
                        } catch (e) {
                            console.log('Could not apply highlight:', e);
                        }
                    });
                }
            }
        }

        function applyZoomToContent() {
            const contentContainer = document.getElementById('contentContainer');
            if (contentContainer) {
                contentContainer.style.transform = `scale(${zoomLevel})`;
                contentContainer.style.transformOrigin = 'top center';
            }
        }

        function toggleBookmark() {
            const fileKey = currentFileName || 'current';
            if (!bookmarks[fileKey]) bookmarks[fileKey] = [];
            
            const existingIndex = bookmarks[fileKey].findIndex(b => b.page === currentPage);
            
            if (existingIndex > -1) {
                bookmarks[fileKey].splice(existingIndex, 1);
                alert('Bookmark removed');
            } else {
                bookmarks[fileKey].push({
                    page: currentPage,
                    timestamp: new Date().toISOString()
                });
                alert('Page bookmarked!');
            }
            
            saveData('bookmarks', bookmarks);
            updateBookmarksList();
        }

        function updateBookmarksList() {
            const list = document.getElementById('bookmarksList');
            list.innerHTML = '';
            
            const fileKey = currentFileName || 'current';
            const fileBookmarks = bookmarks[fileKey] || [];
            
            if (fileBookmarks.length === 0) {
                list.innerHTML = '<p class="text-muted small">No bookmarks yet</p>';
                return;
            }
            
            fileBookmarks.forEach((bookmark, idx) => {
                const item = document.createElement('div');
                item.className = 'bookmark-item';
                item.innerHTML = `
                    <span>Page ${bookmark.page}</span>
                    <button class="btn btn-sm btn-danger" onclick="removeBookmark(${idx}); event.stopPropagation();">
                        <i class="fas fa-times"></i>
                    </button>
                `;
                item.onclick = (e) => {
                    if (!e.target.closest('button')) {
                        jumpToPage(bookmark.page);
                    }
                };
                list.appendChild(item);
            });
        }

        function jumpToPage(pageNumber, searchTerm = null) {
            if (viewMode === 'scroll') {
                // In scroll mode, scroll to the specific page
                const pageContainers = document.querySelectorAll('.page-container[data-page-number]');
                const targetPage = Array.from(pageContainers).find(p => 
                    parseInt(p.dataset.pageNumber) === pageNumber
                );
                
                if (targetPage) {
                    targetPage.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    currentPage = pageNumber;
                    updatePageInfo();
                    
                    if (searchTerm) {
                        setTimeout(() => highlightSearchTermInPage(targetPage, searchTerm), 500);
                    }
                }
            } else {
                // In single or double page mode, render that page
                currentPage = pageNumber;
                renderCurrentPage().then(() => {
                    if (searchTerm) {
                        setTimeout(() => {
                            const containers = document.querySelectorAll('.page-container');
                            containers.forEach(c => highlightSearchTermInPage(c, searchTerm));
                        }, 500);
                    }
                });
            }
        }

        function highlightSearchTermInPage(container, term) {
            const textContent = container.innerText || container.textContent;
            if (!textContent.toLowerCase().includes(term.toLowerCase())) return;
            
            // Get all text nodes
            const walker = document.createTreeWalker(
                container,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            const textNodes = [];
            let node;
            while (node = walker.nextNode()) {
                if (node.textContent.trim()) {
                    textNodes.push(node);
                }
            }
            
            // Highlight term in text nodes
            textNodes.forEach(textNode => {
                const text = textNode.textContent;
                const regex = new RegExp(`(${term})`, 'gi');
                
                if (regex.test(text)) {
                    const span = document.createElement('span');
                    span.innerHTML = text.replace(regex, '<span class="search-highlight-temp">$1</span>');
                    textNode.parentNode.replaceChild(span, textNode);
                }
            });
            
            // Scroll to first highlight
            const firstHighlight = container.querySelector('.search-highlight-temp');
            if (firstHighlight) {
                firstHighlight.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function removeBookmark(idx) {
            const fileKey = currentFileName || 'current';
            if (bookmarks[fileKey]) {
                bookmarks[fileKey].splice(idx, 1);
                saveData('bookmarks', bookmarks);
                updateBookmarksList();
            }
        }

        function openLibrary() {
            updateRecentFilesList();
            new bootstrap.Modal(document.getElementById('libraryModal')).show();
        }

        function openSearch() {
            new bootstrap.Modal(document.getElementById('searchModal')).show();
        }

        function openSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.style.display = sidebar.style.display === 'none' ? 'block' : 'none';
        }

        async function performSearch() {
            const searchTerm = document.getElementById('searchInput').value.trim();
            const resultsDiv = document.getElementById('searchResults');
            
            if (!searchTerm) {
                resultsDiv.innerHTML = '<p class="text-muted">Please enter a search term</p>';
                return;
            }
            
            resultsDiv.innerHTML = '<p class="text-muted">Searching...</p>';
            
            const results = [];
            
            if (fileType === 'pdf' && pdfDoc) {
                for (let i = 1; i <= totalPages; i++) {
                    try {
                        const page = await pdfDoc.getPage(i);
                        const textContent = await page.getTextContent();
                        const text = textContent.items.map(item => item.str).join(' ');
                        
                        if (text.toLowerCase().includes(searchTerm.toLowerCase())) {
                            const index = text.toLowerCase().indexOf(searchTerm.toLowerCase());
                            const preview = text.substring(Math.max(0, index - 40), Math.min(text.length, index + 80));
                            results.push({page: i, preview: preview});
                        }
                    } catch (e) {
                        console.error('Error searching page ' + i, e);
                    }
                }
            } else {
                // Search in EPUB/DOCX
                const container = document.getElementById('contentContainer');
                if (container) {
                    const text = container.innerText;
                    if (text.toLowerCase().includes(searchTerm.toLowerCase())) {
                        const index = text.toLowerCase().indexOf(searchTerm.toLowerCase());
                        const preview = text.substring(Math.max(0, index - 40), Math.min(text.length, index + 80));
                        results.push({page: currentPage, preview: preview});
                        
                        // Highlight in document
                        highlightSearchTerm(container, searchTerm);
                    }
                }
            }
            
            displaySearchResults(results, searchTerm);
        }

        function highlightSearchTerm(container, term) {
            const innerHTML = container.innerHTML;
            const regex = new RegExp(`(${term})`, 'gi');
            container.innerHTML = innerHTML.replace(regex, '<span class="highlight highlight-yellow">$1</span>');
        }

        function displaySearchResults(results, searchTerm) {
            const resultsDiv = document.getElementById('searchResults');
            
            if (results.length === 0) {
                resultsDiv.innerHTML = '<p class="text-muted">No results found</p>';
                return;
            }
            
            resultsDiv.innerHTML = `<p class="text-success"><strong>${results.length}</strong> result(s) found for "${searchTerm}"</p>`;
            
            results.forEach(result => {
                const item = document.createElement('div');
                item.className = 'bookmark-item';
                item.style.flexDirection = 'column';
                item.style.alignItems = 'flex-start';
                item.innerHTML = `
                    <strong>Page ${result.page}</strong>
                    <small class="text-muted">...${result.preview}...</small>
                `;
                item.onclick = () => {
                    jumpToPage(result.page, searchTerm);
                    bootstrap.Modal.getInstance(document.getElementById('searchModal')).hide();
                };
                resultsDiv.appendChild(item);
            });
        }

        function clearAllBookmarks() {
            if (confirm('Clear all bookmarks for this file?')) {
                const fileKey = currentFileName || 'current';
                if (bookmarks[fileKey]) {
                    bookmarks[fileKey] = [];
                    saveData('bookmarks', bookmarks);
                    updateBookmarksList();
                }
            }
        }

        function clearAllHighlights() {
            if (confirm('Clear all highlights for this file?')) {
                const fileKey = currentFileName || 'current';
                if (highlights[fileKey]) {
                    highlights[fileKey] = [];
                    saveData('highlights', highlights);
                    updateHighlightsList();
                    
                    // Remove visual highlights from page
                    document.querySelectorAll('.highlight').forEach(el => {
                        const parent = el.parentNode;
                        parent.replaceChild(document.createTextNode(el.textContent), el);
                        parent.normalize();
                    });
                }
            }
        }

        function toggleAnnotationMode() {
            annotationMode = !annotationMode;
            const btn = document.getElementById('annotateBtn');
            
            if (annotationMode) {
                btn.classList.add('active');
                alert('Annotation mode ON. Click anywhere on the page to add an annotation. Click the button again to turn off.');
                
                // Add click listener for annotations
                setTimeout(() => {
                    const containers = document.querySelectorAll('.page-container');
                    containers.forEach(c => {
                        c.style.cursor = 'crosshair';
                        c.addEventListener('click', handleAnnotationClick);
                    });
                }, 100);
            } else {
                btn.classList.remove('active');
                const containers = document.querySelectorAll('.page-container');
                containers.forEach(c => {
                    c.style.cursor = 'default';
                    c.removeEventListener('click', handleAnnotationClick);
                });
            }
        }

        function handleAnnotationClick(e) {
            if (!annotationMode) return;
            
            e.stopPropagation();
            
            // Get click position relative to page
            const pageContainer = e.currentTarget;
            const rect = pageContainer.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Get selection if any
            const selection = window.getSelection();
            const selectedText = selection.toString().trim();
            
            // Store position for annotation marker
            window.pendingAnnotation = { x, y, page: currentPage };
            
            document.getElementById('annotationPageNum').textContent = currentPage;
            document.getElementById('annotationContext').textContent = selectedText || '';
            document.getElementById('annotationText').value = '';
            
            const modal = new bootstrap.Modal(document.getElementById('annotationModal'));
            modal.show();
            
            // Turn off annotation mode
            toggleAnnotationMode();
        }

        function saveAnnotation() {
            const text = document.getElementById('annotationText').value.trim();
            if (!text) return;
            
            const context = document.getElementById('annotationContext').textContent;
            const fileKey = currentFileName || 'current';
            const position = window.pendingAnnotation || { x: 50, y: 50, page: currentPage };
            
            if (!annotations[fileKey]) annotations[fileKey] = [];
            
            const annotationId = Date.now().toString();
            
            annotations[fileKey].push({
                id: annotationId,
                page: position.page,
                text: text,
                context: context,
                x: position.x,
                y: position.y,
                timestamp: new Date().toISOString()
            });
            
            saveData('annotations', annotations);
            updateAnnotationsList();
            loadAnnotationsForPage(position.page);
            
            window.pendingAnnotation = null;
            
            bootstrap.Modal.getInstance(document.getElementById('annotationModal')).hide();
        }

        function loadAnnotationsForPage(page) {
            // Remove existing annotation markers
            document.querySelectorAll('.annotation-marker').forEach(el => el.remove());
            document.querySelectorAll('.annotation-tooltip').forEach(el => el.remove());
            
            const fileKey = currentFileName || 'current';
            const pageAnnotations = annotations[fileKey]?.filter(a => a.page === page) || [];
            
            pageAnnotations.forEach(annotation => {
                const containers = document.querySelectorAll('.page-container');
                containers.forEach(container => {
                    if (parseInt(container.dataset.pageNumber) === page || fileType !== 'pdf') {
                        const marker = document.createElement('div');
                        marker.className = 'annotation-marker';
                        marker.innerHTML = '<i class="fas fa-sticky-note"></i>';
                        marker.style.left = annotation.x + 'px';
                        marker.style.top = annotation.y + 'px';
                        marker.dataset.annotationId = annotation.id;
                        
                        const tooltip = document.createElement('div');
                        tooltip.className = 'annotation-tooltip';
                        tooltip.innerHTML = `
                            <strong>Annotation</strong>
                            <p class="mb-1 small">${annotation.context}</p>
                            <p class="mb-0">${annotation.text}</p>
                            <button class="btn btn-sm btn-danger mt-2" onclick="deleteAnnotation('${annotation.id}')">Delete</button>
                        `;
                        
                        marker.addEventListener('mouseenter', function() {
                            const rect = marker.getBoundingClientRect();
                            tooltip.style.left = (rect.right + 10) + 'px';
                            tooltip.style.top = rect.top + 'px';
                            tooltip.style.display = 'block';
                            document.body.appendChild(tooltip);
                        });
                        
                        marker.addEventListener('mouseleave', function() {
                            tooltip.style.display = 'none';
                            if (tooltip.parentNode) {
                                tooltip.parentNode.removeChild(tooltip);
                            }
                        });
                        
                        container.appendChild(marker);
                    }
                });
            });
        }

        function deleteAnnotation(annotationId) {
            const fileKey = currentFileName || 'current';
            if (!annotations[fileKey]) return;
            
            annotations[fileKey] = annotations[fileKey].filter(a => a.id !== annotationId);
            saveData('annotations', annotations);
            updateAnnotationsList();
            loadAnnotationsForPage(currentPage);
        }

        function updateAnnotationsList() {
            const list = document.getElementById('annotationsList');
            list.innerHTML = '';
            
            const fileKey = currentFileName || 'current';
            const fileAnnotations = annotations[fileKey] || [];
            
            if (fileAnnotations.length === 0) {
                list.innerHTML = '<p class="text-muted small">No annotations yet</p>';
                return;
            }
            
            fileAnnotations.forEach(annotation => {
                const item = document.createElement('div');
                item.className = 'bookmark-item';
                item.style.flexDirection = 'column';
                item.style.alignItems = 'flex-start';
                item.style.cursor = 'pointer';
                item.innerHTML = `
                    <strong>Page ${annotation.page}</strong>
                    ${annotation.context ? `<small class="text-muted">"${annotation.context.substring(0, 50)}..."</small>` : ''}
                    <p class="mb-0 mt-1">${annotation.text}</p>
                    <button class="btn btn-sm btn-danger mt-2" onclick="event.stopPropagation(); deleteAnnotation('${annotation.id}')">
                        <i class="fas fa-times"></i> Delete
                    </button>
                `;
                item.onclick = (e) => {
                    if (!e.target.closest('button')) {
                        jumpToAnnotation(annotation);
                    }
                };
                list.appendChild(item);
            });
        }

        function jumpToAnnotation(annotation) {
            jumpToPage(annotation.page);
            
            // After jumping to page, scroll to annotation marker if visible
            setTimeout(() => {
                const marker = document.querySelector(`[data-annotation-id="${annotation.id}"]`);
                if (marker) {
                    marker.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    // Flash the marker
                    marker.style.transform = 'scale(1.5)';
                    setTimeout(() => {
                        marker.style.transform = 'scale(1)';
                    }, 300);
                }
            }, 500);
        }

        function clearAllAnnotations() {
            if (confirm('Clear all annotations for this file?')) {
                const fileKey = currentFileName || 'current';
                if (annotations[fileKey]) {
                    annotations[fileKey] = [];
                    saveData('annotations', annotations);
                    updateAnnotationsList();
                    loadAnnotationsForPage(currentPage);
                }
            }
        }

        function showContextMenu(x, y) {
            const menu = document.getElementById('contextMenu');
            menu.style.display = 'block';
            menu.style.left = Math.min(x, window.innerWidth - 220) + 'px';
            menu.style.top = Math.min(y, window.innerHeight - 300) + 'px';
        }

        function hideContextMenu() {
            document.getElementById('contextMenu').style.display = 'none';
        }

        function contextMenuAction(action) {
            const selectedText = contextMenuSelection;
            if (!selectedText) return;
            
            hideContextMenu();
            
            switch(action) {
                case 'copy':
                    navigator.clipboard.writeText(selectedText);
                    // Silent copy - no alert
                    break;
                    
                case 'highlight':
                    // Get current selection and store it
                    const currentSelection = window.getSelection();
                    if (!currentSelection.toString().trim()) return;
                    
                    const range = currentSelection.getRangeAt(0).cloneRange();
                    
                    // Enable highlight mode temporarily
                    highlightMode = true;
                    
                    // Create new selection from stored range
                    window.getSelection().removeAllRanges();
                    window.getSelection().addRange(range);
                    
                    // Trigger highlight
                    handleTextSelection({});
                    
                    // Reset highlight mode
                    highlightMode = false;
                    break;
                    
                case 'annotate':
                    document.getElementById('annotationPageNum').textContent = currentPage;
                    document.getElementById('annotationContext').textContent = selectedText.substring(0, 100);
                    document.getElementById('annotationText').value = '';
                    
                    // Store position for annotation
                    const sel = window.getSelection();
                    if (sel.rangeCount > 0) {
                        const range = sel.getRangeAt(0);
                        const rect = range.getBoundingClientRect();
                        const container = document.querySelector('.page-container');
                        const containerRect = container.getBoundingClientRect();
                        window.pendingAnnotation = {
                            x: rect.left - containerRect.left + 20,
                            y: rect.top - containerRect.top + 20,
                            page: currentPage
                        };
                    }
                    
                    new bootstrap.Modal(document.getElementById('annotationModal')).show();
                    break;
                    
                case 'clipToNotes':
                    const fileKey = currentFileName || 'current';
                    if (!clippedNotes[fileKey]) clippedNotes[fileKey] = [];
                    
                    clippedNotes[fileKey].push({
                        page: currentPage,
                        text: selectedText,
                        fileName: currentFileName,
                        timestamp: new Date().toISOString()
                    });
                    
                    saveData('clippedNotes', clippedNotes);
                    updateNotesList();
                    // No alert - silent clip
                    break;
                    
                case 'search':
                    document.getElementById('searchInput').value = selectedText;
                    openSearch();
                    setTimeout(() => performSearch(), 100);
                    break;
                    
                case 'dictionary':
                    const word = selectedText.split(/\s+/)[0].replace(/[^a-zA-Z]/g, '');
                    if (word) {
                        showDictionary(word, window.innerWidth / 2, window.innerHeight / 2);
                    }
                    break;
            }
            
            contextMenuSelection = null;
        }

        function clearReadingStats() {
            if (confirm('Clear all reading statistics? This cannot be undone.')) {
                readingStats = {totalTime: 0, pagesRead: {}, sessions: []};
                saveData('readingStats', readingStats);
                updateStats();
                alert('Reading statistics cleared');
            }
        }

        function changeFontSize(value) {
            document.getElementById('fontSizeLabel').textContent = value + 'px';
            const container = document.getElementById('contentContainer');
            if (container) {
                container.style.fontSize = value + 'px';
            }
        }

        function changeLineSpacing(value) {
            const container = document.getElementById('contentContainer');
            if (container) {
                container.style.lineHeight = value;
            }
        }

        // Initialize on load
        updateBookmarksList();
        updateHighlightsList();
        updateRecentFilesList();
        updateNotesList();
        
        // Start stats tracking if there's a file loaded
        if (currentFile) {
            startReadingSession();
        }
        
        // Load saved theme
        const savedTheme = localStorage.getItem('displayTheme');
        if (savedTheme) {
            document.getElementById('displayTheme').value = savedTheme;
            changeDisplayTheme(savedTheme);
        }
    </script>
</body>
</html>